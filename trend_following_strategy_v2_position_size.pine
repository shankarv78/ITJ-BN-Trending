//@version=5
strategy("Trend Following Strategy V2 - Enhanced Position Sizing",
    overlay=true,
    pyramiding=3,
    initial_capital=5000000,
    default_qty_type=strategy.fixed,
    default_qty_value=1,
    calc_on_every_tick=true,
    calc_on_order_fills=false,
    process_orders_on_close=true,
    commission_type=strategy.commission.percent,
    commission_value=0.1)

// ========================================
// PARAMETERS
// ========================================

// RSI Parameters
rsi_period = input.int(6, "RSI Period", minval=1)
rsi_threshold = input.float(70, "RSI Overbought", minval=0, maxval=100, tooltip="Standard overbought level")
rsi_high_threshold = input.float(80, "RSI High Overbought", minval=0, maxval=100, tooltip="High overbought level (more extreme)")

// EMA Parameters
ema_period = input.int(200, "EMA Period", minval=1)

// Donchian Channel Parameters
dc_period = input.int(20, "DC Period", minval=1)

// ADX Parameters
adx_period = input.int(30, "ADX Period", minval=1)
adx_threshold = input.float(25, "ADX Threshold", minval=0)

// Efficiency Ratio Parameters (as per provided code)
er_period = input.int(3, "ER Period", minval=1)
er_directional = input.bool(false, "ER Directional")
er_threshold = input.float(0.8, "ER Threshold", minval=0, maxval=1)

// ROC (Rate of Change) Parameters
roc_period = input.int(15, "ROC Period", minval=1, tooltip="Rate of Change lookback period")
use_roc_for_pyramids = input.bool(false, "Use ROC Filter for Pyramids", tooltip="Enable ROC momentum check before pyramiding")
roc_threshold = input.float(0.0, "ROC Threshold %", minval=-10, maxval=20, step=0.5, tooltip="Minimum ROC % required for pyramiding (0 = must be positive)")

// SuperTrend Parameters
st_period = input.int(10, "ST Period", minval=1)
st_multiplier = input.float(1.5, "ST Multiplier", minval=0.1, step=0.1)

// Doji Detection Parameter
doji_threshold = input.float(0.1, "Doji Body/Range Ratio", minval=0.01, maxval=0.3, step=0.01, tooltip="Body size as % of candle range. Lower = stricter doji detection")

// Debug Mode
show_debug = input.bool(false, "Show Debug Panel", tooltip="Show detailed condition status in separate pane (not recommended - use info table instead)")

// Indicator Display Options
show_donchian = input.bool(false, "Show Donchian Channel", tooltip="Display DC upper/lower/middle bands on chart")
show_rsi = input.bool(false, "Show RSI", tooltip="Display RSI in separate pane")
show_adx = input.bool(false, "Show ADX", tooltip="Display ADX in separate pane")
show_er = input.bool(false, "Show Efficiency Ratio", tooltip="Display ER in separate pane")
show_atr = input.bool(false, "Show ATR", tooltip="Display ATR in separate pane")

// Info Panel Display Mode
smart_panel = input.bool(true, "Smart Info Panel", tooltip="Show indicators when flat, trade info when in position")
show_all_info = input.bool(false, "Show All Info (Debug)", tooltip="Show both indicators and trade info always (for debugging)")

// Position Sizing Parameters
risk_percent = input.float(2.0, "Risk % of Capital", minval=0.1, maxval=10, step=0.1, tooltip="Percentage of capital to risk per trade")
lot_size = input.int(35, "Lot Size", minval=1, tooltip="Contract lot size (Bank Nifty = 15, but using 35 as specified)")

// Margin Management (for Synthetic Futures: ATM PE Sell + ATM CE Buy)
use_margin_check = input.bool(true, "Enable Margin Check", tooltip="Prevent pyramiding if insufficient margin available")
margin_per_lot = input.float(2.6, "Margin per Lot (Lakhs)", minval=0.1, step=0.1, tooltip="Approximate margin required per lot for synthetic future (ATM PE Sell + CE Buy)")
use_leverage = input.bool(false, "Use Leverage", tooltip="Enable leverage for margin calculations")
leverage_multiplier = input.float(1.0, "Leverage Multiplier", minval=0.1, maxval=10, step=0.1, tooltip="Multiply available margin by this factor (1.0 = no leverage, 2.0 = 2x leverage)")

// Pyramiding Parameters
enable_pyramiding = input.bool(true, "Enable Pyramiding", tooltip="Allow adding to winning positions")
max_pyramids = input.int(3, "Max Pyramids", minval=1, maxval=3, tooltip="Maximum number of pyramid entries (3 = 4 total positions)")
atr_pyramid_threshold = input.float(0.75, "ATR Pyramid Threshold", minval=0.25, maxval=2.0, step=0.25, tooltip="ATR multiplier for pyramid triggers (0.75 = add every 0.75 ATR move)")
pyramid_size_ratio = input.float(0.5, "Pyramid Size Ratio", minval=0.25, maxval=1.0, step=0.05, tooltip="Size of each pyramid as ratio of previous entry (0.5 = 50%)")

// Stop Loss Management
stop_loss_mode = input.string("SuperTrend", "Stop Loss Mode", options=["SuperTrend", "Van Tharp", "Tom Basso"], tooltip="SuperTrend: All entries use ST as SL | Van Tharp: Trail previous entries to breakeven | Tom Basso: ATR-based trailing stop")
atr_period_pyramid = input.int(10, "ATR Period (Pyramiding)", minval=1, tooltip="ATR period for calculating pyramid triggers")

// Tom Basso ATR Trailing Stop Parameters (only used if mode = "Tom Basso")
basso_initial_atr_mult = input.float(1.0, "Basso Initial Stop (× ATR)", minval=0.5, maxval=5.0, step=0.5, tooltip="Initial stop distance from entry (multiplier of ATR)")
basso_trailing_atr_mult = input.float(2.0, "Basso Trailing Stop (× ATR)", minval=1.0, maxval=5.0, step=0.5, tooltip="Trailing stop distance from highest close (multiplier of ATR)")
basso_atr_period = input.int(10, "Basso ATR Period", minval=5, maxval=50, tooltip="ATR period for Tom Basso stop calculation")

// Trade Start Date Filter
use_start_date = input.bool(true, "Use Start Date Filter", tooltip="Only allow trades from specified date onwards")
start_date = input.time(timestamp("11 Nov 2025 00:00 +0000"), "Trade Start Date", tooltip="Strategy will only take trades from this date onwards")

// ========================================
// INDICATOR CALCULATIONS
// ========================================

// RSI
rsi = ta.rsi(close, rsi_period)

// EMA
ema = ta.ema(close, ema_period)

// Donchian Channel (Upper band only for entry condition)
// Use [1] offset to check against PREVIOUS period's high, not including current bar
dc_upper = ta.highest(high[1], dc_period)
dc_lower = ta.lowest(low[1], dc_period)
dc_middle = (dc_upper + dc_lower) / 2

// ADX Calculation
[diPlus, diMinus, adx] = ta.dmi(adx_period, adx_period)

// Efficiency Ratio (Using exact code provided by user)
ER(src, p, dir) =>
    a = dir ? src - src[p] : math.abs(src - src[p])
    b = 0.0
    for i = 0 to p-1
        b := b + math.abs(src[i] - src[i+1])
    result = b != 0 ? a / b : 0
    result

er = ER(close, er_period, er_directional)

// SuperTrend (10, 1.5)
[supertrend, direction] = ta.supertrend(st_multiplier, st_period)

// ATR for Pyramiding
atr_pyramid = ta.atr(atr_period_pyramid)

// ATR for Tom Basso Mode
atr_basso = ta.atr(basso_atr_period)

// ROC (Rate of Change)
roc = ta.roc(close, roc_period)

// Doji Detection
// A doji has a very small body relative to the candle's range
body_size = math.abs(close - open)
candle_range = high - low
is_doji = candle_range > 0 ? (body_size / candle_range) <= doji_threshold : false

// End-of-Day Detection (for gap-up capture)
// 75-min timeframe: ~5 candles per day (9:15 AM - 3:30 PM = 375 min / 75 = 5 candles)
// Last candle typically closes around 3:30 PM (15:30 or 1530 in session format)
is_eod_candle = hour(time) >= 14 and minute(time) >= 15  // After 2:15 PM
is_market_close = hour(time) == 15 and minute(time) >= 15  // After 3:15 PM (near close)

// ========================================
// STRATEGY CONDITIONS
// ========================================

// Entry Conditions (ALL must be true at candle close)
rsi_condition = rsi > rsi_threshold
ema_condition = close > ema
dc_condition = close > dc_upper
adx_condition = adx < adx_threshold
er_condition = er > er_threshold
st_condition = close > supertrend  // Price above SuperTrend (bullish)
not_doji = not is_doji  // Candle is NOT a doji

// Date Filter: Only allow trades from start_date onwards
date_filter = use_start_date ? time >= start_date : true

// Combine all conditions for long entry
long_entry = rsi_condition and ema_condition and dc_condition and adx_condition and er_condition and st_condition and not_doji and date_filter

// Exit Condition: Candle closes below SuperTrend
long_exit = close < supertrend

// ========================================
// STRATEGY EXECUTION
// ========================================
// With process_orders_on_close=true:
// - Orders execute at the close of the current bar
// - This captures gap-ups when end-of-day candle triggers entry
// - Entry price = close price of signal bar

// ========================================
// PYRAMIDING & POSITION MANAGEMENT - V2 ENHANCED
// ========================================
// NEW LOGIC:
// - 2% max risk per entry based on CURRENT equity (realized + unrealized)
// - Pyramiding allowed only when accumulated profit covers base trade risk
// - Pyramid size = min(lot-a, lot-b, lot-c) where:
//   lot-a = Margin constraint (current_equity / margin_per_lot)
//   lot-b = 50% of base lot size (traditional pyramiding rule)
//   lot-c = Risk budget based (50% of [profit - base_risk] / SL_distance)

var float equity_high = strategy.initial_capital  // Track highest equity reached
var float initial_entry_price = na  // First entry price (Long_1)
var float pyr1_entry_price = na  // Pyramid 1 entry price (Long_2)
var float pyr2_entry_price = na  // Pyramid 2 entry price (Long_3)
var float pyr3_entry_price = na  // Pyramid 3 entry price (Long_4)
var float last_pyramid_price = na  // Most recent pyramid entry price
var int pyramid_count = 0  // Number of pyramids added
var float initial_position_size = 0  // Size of first entry

// Tom Basso Mode: Track stops and highest close for each entry
var float basso_stop_long1 = na
var float basso_stop_long2 = na
var float basso_stop_long3 = na
var float basso_stop_long4 = na
var float highest_close_long1 = na
var float highest_close_long2 = na
var float highest_close_long3 = na
var float highest_close_long4 = na

// Update equity high watermark - ONLY with REALIZED profits (closed trades only)
realized_equity = strategy.initial_capital + strategy.netprofit
if realized_equity > equity_high
    equity_high := realized_equity

// NEW: Use CURRENT equity (realized + unrealized) for position sizing
current_equity = strategy.equity

// Calculate accumulated profit (realized + unrealized)
accumulated_profit = (current_equity - strategy.initial_capital)
unrealized_pnl = strategy.openprofit
realized_profit = strategy.netprofit

// Margin tracking
current_equity_lakhs = current_equity / 100000
realized_equity_lakhs = realized_equity / 100000
available_margin_lakhs = use_leverage ? current_equity_lakhs * leverage_multiplier : current_equity_lakhs
current_margin_used_display = strategy.position_size * margin_per_lot
margin_remaining = available_margin_lakhs - current_margin_used_display
margin_utilization_pct = available_margin_lakhs > 0 ? (current_margin_used_display / available_margin_lakhs) * 100 : 0

// Calculate stop loss levels and risk exposure for display
var float display_stop_long1 = na
var float display_stop_long2 = na
var float display_stop_long3 = na
var float display_stop_long4 = na

if strategy.position_size > 0
    if stop_loss_mode == "SuperTrend"
        // All positions use SuperTrend
        display_stop_long1 := not na(initial_entry_price) ? supertrend : na
        display_stop_long2 := not na(pyr1_entry_price) ? supertrend : na
        display_stop_long3 := not na(pyr2_entry_price) ? supertrend : na
        display_stop_long4 := not na(pyr3_entry_price) ? supertrend : na
    else if stop_loss_mode == "Van Tharp"
        // Trail to next pyramid or SuperTrend
        display_stop_long1 := not na(initial_entry_price) ? (not na(pyr1_entry_price) ? pyr1_entry_price : supertrend) : na
        display_stop_long2 := not na(pyr1_entry_price) ? (not na(pyr2_entry_price) ? pyr2_entry_price : supertrend) : na
        display_stop_long3 := not na(pyr2_entry_price) ? (not na(pyr3_entry_price) ? pyr3_entry_price : supertrend) : na
        display_stop_long4 := not na(pyr3_entry_price) ? supertrend : na
    else if stop_loss_mode == "Tom Basso"
        // Individual ATR trailing stops
        display_stop_long1 := basso_stop_long1
        display_stop_long2 := basso_stop_long2
        display_stop_long3 := basso_stop_long3
        display_stop_long4 := basso_stop_long4

// Calculate risk exposure per position (if stopped out)
risk_long1 = not na(initial_entry_price) and not na(display_stop_long1) ? math.max(0, (initial_entry_price - display_stop_long1) * initial_position_size * lot_size) : 0
risk_long2 = not na(pyr1_entry_price) and not na(display_stop_long2) ? math.max(0, (pyr1_entry_price - display_stop_long2) * initial_position_size * pyramid_size_ratio * lot_size) : 0
risk_long3 = not na(pyr2_entry_price) and not na(display_stop_long3) ? math.max(0, (pyr2_entry_price - display_stop_long3) * initial_position_size * math.pow(pyramid_size_ratio, 2) * lot_size) : 0
risk_long4 = not na(pyr3_entry_price) and not na(display_stop_long4) ? math.max(0, (pyr3_entry_price - display_stop_long4) * initial_position_size * math.pow(pyramid_size_ratio, 3) * lot_size) : 0
total_risk_exposure = risk_long1 + risk_long2 + risk_long3 + risk_long4

// INITIAL ENTRY: When all conditions are met and no position exists
if long_entry and strategy.position_size == 0
    // Calculate risk amount (2% of CURRENT equity - includes unrealized)
    risk_amount = current_equity * (risk_percent / 100)

    // Entry price and stop
    entry_price = close
    stop_loss = supertrend

    // Risk per lot in points and rupees
    risk_per_point = entry_price - stop_loss
    risk_per_lot = risk_per_point * lot_size

    // Calculate number of lots based on RISK: (Risk ÷ ((Entry - ST) × Lot_Size)) × ER
    risk_based_lots = risk_per_lot > 0 ? (risk_amount / risk_per_lot) * er : 0
    risk_based_lots_floored = math.floor(risk_based_lots)  // Always round DOWN

    // Calculate max lots based on AVAILABLE MARGIN
    margin_based_lots = available_margin_lakhs > 0 ? math.floor(available_margin_lakhs / margin_per_lot) : 0

    // Take MINIMUM of risk-based and margin-based (ensures we never exceed available margin)
    // Both are floored, so final_lots will NEVER exceed available margin
    // Ensure result is valid (0 if less than 1 lot affordable)
    final_lots = math.max(0, math.min(risk_based_lots_floored, margin_based_lots))

    // Only enter if we can afford at least 1 lot
    if final_lots >= 1
        // Store initial entry details
        initial_entry_price := close
        last_pyramid_price := close
        pyramid_count := 0
        initial_position_size := final_lots

        // Initialize Tom Basso stop for Long_1
        if stop_loss_mode == "Tom Basso"
            basso_stop_long1 := close - (basso_initial_atr_mult * atr_basso)
            highest_close_long1 := close

        // Enter with calculated lot size
        // Add EOD marker to comment for gap-up tracking
        entry_comment = is_eod_candle ? "EOD-ENTRY-" + str.tostring(final_lots) + "L" : "ENTRY-" + str.tostring(final_lots) + "L"
        strategy.entry("Long_1", strategy.long, qty=final_lots, comment=entry_comment)

// ========================================
// PYRAMIDING - V2 ENHANCED POSITION SIZING
// ========================================
// NEW LOGIC: Pyramid lot size = min(lot-a, lot-b, lot-c)
// lot-a: Margin constraint
// lot-b: 50% of base lot size
// lot-c: Risk budget (50% of [accumulated_profit - base_risk])
// Gate: Can only pyramid if accumulated_profit > base_risk

// Variables for debugging/display
var float pyramid_lot_a = 0
var float pyramid_lot_b = 0
var float pyramid_lot_c = 0
var float profit_after_base_risk = 0
var bool pyramid_gated = false

if enable_pyramiding and strategy.position_size > 0 and pyramid_count < max_pyramids
    // Calculate how far price has moved from last entry
    price_move_from_last = close - last_pyramid_price
    atr_moves = price_move_from_last / atr_pyramid

    // Calculate current stop for base trade
    current_stop_base = display_stop_long1

    // Calculate base trade risk (ongoing risk if SL is hit)
    base_risk = not na(initial_entry_price) and not na(current_stop_base) ?
                math.max(0, (initial_entry_price - current_stop_base) * initial_position_size * lot_size) : 0

    // NEW GATE: Can only pyramid if accumulated profit > base risk
    pyramid_gated := accumulated_profit > base_risk
    profit_after_base_risk := accumulated_profit - base_risk

    // Only proceed if gate is passed
    if pyramid_gated and profit_after_base_risk > 0

        // ===== lot-a: MARGIN CONSTRAINT =====
        // Based on available margin
        current_margin_used = strategy.position_size * margin_per_lot
        free_margin = available_margin_lakhs - current_margin_used
        pyramid_lot_a := free_margin > 0 ? math.floor(free_margin / margin_per_lot) : 0

        // ===== lot-b: 50% OF BASE LOT SIZE =====
        // Traditional pyramiding rule
        pyramid_lot_b := math.floor(initial_position_size * pyramid_size_ratio)

        // ===== lot-c: RISK BUDGET CALCULATION =====
        // Can risk 50% of profit_after_base_risk
        // Calculate stop distance for pyramid entry
        pyramid_stop = stop_loss_mode == "Tom Basso" ?
                       (close - (basso_initial_atr_mult * atr_basso)) :
                       supertrend
        pyramid_sl_distance = close - pyramid_stop
        pyramid_risk_per_lot = pyramid_sl_distance * lot_size

        // Available risk budget = 50% of profit_after_base_risk
        available_risk_budget = profit_after_base_risk * 0.5

        // Calculate lots based on risk budget
        pyramid_lot_c := pyramid_risk_per_lot > 0 ?
                         math.floor(available_risk_budget / pyramid_risk_per_lot) : 0

        // ===== FINAL PYRAMID SIZE: min(lot-a, lot-b, lot-c) =====
        pyramid_lots = math.min(pyramid_lot_a, math.min(pyramid_lot_b, pyramid_lot_c))

        // ROC momentum check (optional filter for pyramids)
        roc_ok_for_pyramid = use_roc_for_pyramids ? roc > roc_threshold : true

        // Trigger: Price moved enough AND all lot constraints met AND ROC momentum
        pyramid_trigger = atr_moves >= atr_pyramid_threshold and pyramid_lots >= 1 and roc_ok_for_pyramid

        if pyramid_trigger

            // Update tracking
            pyramid_count := pyramid_count + 1
            last_pyramid_price := close

            // Track individual pyramid entry prices (for Van Tharp mode)
            if pyramid_count == 1
                pyr1_entry_price := close
                // Initialize Tom Basso stop for Long_2
                if stop_loss_mode == "Tom Basso"
                    basso_stop_long2 := close - (basso_initial_atr_mult * atr_basso)
                    highest_close_long2 := close
            else if pyramid_count == 2
                pyr2_entry_price := close
                // Initialize Tom Basso stop for Long_3
                if stop_loss_mode == "Tom Basso"
                    basso_stop_long3 := close - (basso_initial_atr_mult * atr_basso)
                    highest_close_long3 := close
            else if pyramid_count == 3
                pyr3_entry_price := close
                // Initialize Tom Basso stop for Long_4
                if stop_loss_mode == "Tom Basso"
                    basso_stop_long4 := close - (basso_initial_atr_mult * atr_basso)
                    highest_close_long4 := close

            // Enter pyramid
            strategy.entry("Long_" + str.tostring(pyramid_count + 1), strategy.long, qty=pyramid_lots,
                          comment="PYR" + str.tostring(pyramid_count) + "-" + str.tostring(pyramid_lots) + "L")

// STOP LOSS MANAGEMENT
if strategy.position_size > 0
    if stop_loss_mode == "SuperTrend"
        // ========================================
        // Mode 1: SuperTrend (Simple)
        // ========================================
        // All positions use SuperTrend as stop
        if close < supertrend
            strategy.close_all(comment="EXIT - Below ST")
            // Reset tracking
            initial_entry_price := na
            pyr1_entry_price := na
            pyr2_entry_price := na
            pyr3_entry_price := na
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

    else if stop_loss_mode == "Van Tharp"
        // ========================================
        // Mode 2: Van Tharp (Trail to Breakeven)
        // ========================================
        // Trail earlier pyramid entries to the entry price of later pyramids
        // Check each position independently (not based on pyramid_count)

        // Long_1 (Initial Entry): Trail to PYR1 or SuperTrend
        if not na(initial_entry_price)
            if not na(pyr1_entry_price)
                // PYR1 exists above us, trail to it
                if close < pyr1_entry_price
                    strategy.close("Long_1", comment="EXIT - Trail to PYR1")
                    initial_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_1", comment="EXIT - Below ST")
                    initial_entry_price := na

        // Long_2 (PYR1): Trail to PYR2 or SuperTrend
        if not na(pyr1_entry_price)
            if not na(pyr2_entry_price)
                // PYR2 exists above us, trail to it
                if close < pyr2_entry_price
                    strategy.close("Long_2", comment="EXIT - Trail to PYR2")
                    pyr1_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_2", comment="EXIT - Below ST")
                    pyr1_entry_price := na

        // Long_3 (PYR2): Trail to PYR3 or SuperTrend
        if not na(pyr2_entry_price)
            if not na(pyr3_entry_price)
                // PYR3 exists above us, trail to it
                if close < pyr3_entry_price
                    strategy.close("Long_3", comment="EXIT - Trail to PYR3")
                    pyr2_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_3", comment="EXIT - Below ST")
                    pyr2_entry_price := na

        // Long_4 (PYR3): Always trail to SuperTrend (highest level)
        if not na(pyr3_entry_price)
            if close < supertrend
                strategy.close("Long_4", comment="EXIT - Below ST")
                pyr3_entry_price := na

        // If all positions closed, reset everything
        if strategy.position_size == 0
            initial_entry_price := na
            pyr1_entry_price := na
            pyr2_entry_price := na
            pyr3_entry_price := na
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

    else if stop_loss_mode == "Tom Basso"
        // ========================================
        // Mode 3: Tom Basso ATR Trailing Stop
        // ========================================
        // Each position has its own ATR-based trailing stop
        // Stop = max(Initial Stop, Highest Close - Trailing ATR)
        // Using manual tracking instead of ta.highest() to avoid buffer issues

        // Update trailing stops for each position
        // Long_1 (Initial Entry)
        if not na(initial_entry_price)
            // Update highest close since entry
            highest_close_long1 := math.max(highest_close_long1, close)
            // Calculate trailing stop
            trailing_stop_long1 = highest_close_long1 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long1 := math.max(basso_stop_long1, trailing_stop_long1)  // Only move up

            // Exit Long_1 if close below trailing stop
            if close < basso_stop_long1
                strategy.close("Long_1", comment="EXIT - Basso Stop")
                initial_entry_price := na
                basso_stop_long1 := na
                highest_close_long1 := na

        // Long_2 (PYR1)
        if not na(pyr1_entry_price)
            highest_close_long2 := math.max(highest_close_long2, close)
            trailing_stop_long2 = highest_close_long2 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long2 := math.max(basso_stop_long2, trailing_stop_long2)

            if close < basso_stop_long2
                strategy.close("Long_2", comment="EXIT - Basso Stop")
                pyr1_entry_price := na
                basso_stop_long2 := na
                highest_close_long2 := na

        // Long_3 (PYR2)
        if not na(pyr2_entry_price)
            highest_close_long3 := math.max(highest_close_long3, close)
            trailing_stop_long3 = highest_close_long3 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long3 := math.max(basso_stop_long3, trailing_stop_long3)

            if close < basso_stop_long3
                strategy.close("Long_3", comment="EXIT - Basso Stop")
                pyr2_entry_price := na
                basso_stop_long3 := na
                highest_close_long3 := na

        // Long_4 (PYR3)
        if not na(pyr3_entry_price)
            highest_close_long4 := math.max(highest_close_long4, close)
            trailing_stop_long4 = highest_close_long4 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long4 := math.max(basso_stop_long4, trailing_stop_long4)

            if close < basso_stop_long4
                strategy.close("Long_4", comment="EXIT - Basso Stop")
                pyr3_entry_price := na
                basso_stop_long4 := na
                highest_close_long4 := na

        // If all positions closed, reset
        if strategy.position_size == 0
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

// ========================================
// PLOTTING
// ========================================

// Always plot EMA and SuperTrend on main chart
plot(ema, "EMA 200", color=color.blue, linewidth=2, force_overlay=true)
plot(supertrend, "SuperTrend (10,1.5)", color=direction < 0 ? color.new(color.green, 0) : color.new(color.red, 0), linewidth=2, style=plot.style_line, force_overlay=true)

// Optional: Donchian Channel on main chart
plot(show_donchian ? dc_upper : na, "DC Upper", color=color.new(color.green, 0), linewidth=1, style=plot.style_line, force_overlay=true)
plot(show_donchian ? dc_lower : na, "DC Lower", color=color.new(color.red, 0), linewidth=1, style=plot.style_line, force_overlay=true)
plot(show_donchian ? dc_middle : na, "DC Middle", color=color.new(color.gray, 50), linewidth=1, style=plot.style_circles, force_overlay=true)

// Optional: RSI (separate pane - different scale from price)
plot(show_rsi ? rsi : na, "RSI(6)", color=color.new(color.purple, 0), linewidth=2)
hline(show_rsi ? 70 : na, "RSI 70", color=color.new(color.red, 50), linestyle=hline.style_dashed)
hline(show_rsi ? 30 : na, "RSI 30", color=color.new(color.green, 50), linestyle=hline.style_dashed)
hline(show_rsi ? 50 : na, "RSI 50", color=color.new(color.gray, 70), linestyle=hline.style_dotted)

// Optional: ADX (separate pane - different scale from price)
plot(show_adx ? adx : na, "ADX(30)", color=color.new(color.orange, 0), linewidth=2)
hline(show_adx ? 25 : na, "ADX 25", color=color.new(color.orange, 50), linestyle=hline.style_dashed)
hline(show_adx ? 50 : na, "ADX 50", color=color.new(color.red, 50), linestyle=hline.style_dotted)

// Optional: Efficiency Ratio (separate pane - different scale from price)
plot(show_er ? er : na, "ER(3)", color=color.new(color.blue, 0), linewidth=2)
hline(show_er ? 0.8 : na, "ER 0.8", color=color.new(color.green, 50), linestyle=hline.style_dashed)
hline(show_er ? 0.5 : na, "ER 0.5", color=color.new(color.gray, 50), linestyle=hline.style_dotted)
hline(show_er ? 0 : na, "ER 0", color=color.new(color.gray, 70), linestyle=hline.style_solid)

// Optional: ATR (separate pane - different scale from price)
plot(show_atr ? atr_pyramid : na, "ATR(10)", color=color.new(color.maroon, 0), linewidth=2)

// Visual markers for entries and exits - SMALL ARROWS at bar close (on main chart)
plotshape(long_entry and strategy.position_size == 0,
    title="Entry Signal",
    location=location.belowbar,
    color=color.new(color.lime, 0),
    style=shape.arrowup,
    size=size.tiny,
    text="",
    force_overlay=true)

// Special marker for EOD entries (captures gap-ups)
plotshape(long_entry and strategy.position_size == 0 and is_eod_candle,
    title="EOD Entry (Gap-Up Capture)",
    location=location.belowbar,
    color=color.new(color.yellow, 0),
    style=shape.circle,
    size=size.tiny,
    text="EOD",
    force_overlay=true)

plotshape(long_exit and strategy.position_size > 0,
    title="Exit Signal",
    location=location.abovebar,
    color=color.new(color.red, 0),
    style=shape.arrowdown,
    size=size.tiny,
    text="",
    force_overlay=true)

// ========================================
// SMART INFO PANEL V2 - Enhanced Display
// ========================================
var table infoTable = na

// Smart Info Panel - Context-Aware Display
if barstate.islast
    // Determine what to show based on position status
    in_position = strategy.position_size > 0
    show_indicators = (smart_panel and not in_position) or show_all_info
    show_trade_info = (smart_panel and in_position) or show_all_info

    // Dynamic table size (increased for V2 info)
    num_rows = show_all_info ? 30 : (in_position ? 20 : 14)
    infoTable := table.new(position.top_right, 3, num_rows, border_width=2, bgcolor=color.new(color.white, 0), frame_color=color.black, frame_width=2)

    // Header
    table.cell(infoTable, 0, 0, in_position ? "Position V2" : "Indicator", bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(infoTable, 1, 0, "Value", bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(infoTable, 2, 0, "Status", bgcolor=color.gray, text_color=color.white, text_size=size.normal)

    row = 1

    // === INDICATOR SECTION (when flat or debug mode) ===
    if show_indicators
        table.cell(infoTable, 0, row, "Close")
        table.cell(infoTable, 1, row, str.tostring(close, "#.##"))
        table.cell(infoTable, 2, row, "Current Price")
        row := row + 1

        table.cell(infoTable, 0, row, "RSI(6)")
        table.cell(infoTable, 1, row, str.tostring(rsi, "#.##"))
        table.cell(infoTable, 2, row, rsi_condition ? "✓ >70" : "✗ " + str.tostring(rsi, "#.##"), text_color=rsi_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "EMA(200)")
        table.cell(infoTable, 1, row, str.tostring(ema, "#.##"))
        table.cell(infoTable, 2, row, ema_condition ? "✓ Above" : "✗ Below", text_color=ema_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "DC Upper")
        table.cell(infoTable, 1, row, str.tostring(dc_upper, "#.##"))
        table.cell(infoTable, 2, row, dc_condition ? "✓ Above" : "✗ Below", text_color=dc_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "ADX(30)")
        table.cell(infoTable, 1, row, str.tostring(adx, "#.##"))
        table.cell(infoTable, 2, row, adx_condition ? "✓ <25" : "✗ " + str.tostring(adx, "#.##"), text_color=adx_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "ER(3)")
        table.cell(infoTable, 1, row, str.tostring(er, "#.####"))
        table.cell(infoTable, 2, row, er_condition ? "✓ >0.8" : "✗ " + str.tostring(er, "#.####"), text_color=er_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "SuperTrend")
        table.cell(infoTable, 1, row, str.tostring(supertrend, "#.##"))
        table.cell(infoTable, 2, row, st_condition ? "✓ Above" : "✗ Below", text_color=st_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "Doji Check")
        table.cell(infoTable, 1, row, str.tostring(body_size/(candle_range == 0 ? 1 : candle_range), "#.###"))
        table.cell(infoTable, 2, row, not_doji ? "✓ Not Doji" : "✗ Is Doji", text_color=not_doji ? color.green : color.red)
        row := row + 1

    // === ENTRY SIGNAL (always show) ===
    table.cell(infoTable, 0, row, "ENTRY SIGNAL", bgcolor=long_entry ? color.new(color.green, 70) : color.new(color.red, 70))
    table.cell(infoTable, 1, row, long_entry ? "✓ ALL MET" : "✗ WAITING", text_color=color.white, bgcolor=long_entry ? color.new(color.green, 50) : color.new(color.red, 50))
    table.cell(infoTable, 2, row, in_position ? "IN TRADE" : "NO POSITION", text_color=color.white, bgcolor=in_position ? color.new(color.blue, 50) : color.new(color.gray, 50))
    row := row + 1

    // === TRADE INFO SECTION (when in position or debug mode) ===
    if show_trade_info
        // Position entries and stops
        if not na(initial_entry_price)
            entry_lots = math.round(initial_position_size)
            table.cell(infoTable, 0, row, "Long_1 Entry", bgcolor=color.new(color.blue, 80))
            table.cell(infoTable, 1, row, str.tostring(initial_entry_price, "#.##") + " (" + str.tostring(entry_lots) + "L)", bgcolor=color.new(color.blue, 80))
            table.cell(infoTable, 2, row, "Stop: " + str.tostring(display_stop_long1, "#.##"), bgcolor=color.new(color.blue, 80))
            row := row + 1

        if not na(pyr1_entry_price)
            pyr1_lots = math.round(initial_position_size * pyramid_size_ratio)
            table.cell(infoTable, 0, row, "Long_2 (Pyr1)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr1_entry_price, "#.##") + " (" + str.tostring(pyr1_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "Stop: " + str.tostring(display_stop_long2, "#.##"), bgcolor=color.new(color.green, 80))
            row := row + 1

        if not na(pyr2_entry_price)
            pyr2_lots = math.round(initial_position_size * math.pow(pyramid_size_ratio, 2))
            table.cell(infoTable, 0, row, "Long_3 (Pyr2)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr2_entry_price, "#.##") + " (" + str.tostring(pyr2_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "Stop: " + str.tostring(display_stop_long3, "#.##"), bgcolor=color.new(color.green, 80))
            row := row + 1

        if not na(pyr3_entry_price)
            pyr3_lots = math.round(initial_position_size * math.pow(pyramid_size_ratio, 3))
            table.cell(infoTable, 0, row, "Long_4 (Pyr3)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr3_entry_price, "#.##") + " (" + str.tostring(pyr3_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "Stop: " + str.tostring(display_stop_long4, "#.##"), bgcolor=color.new(color.green, 80))
            row := row + 1

        // Total position
        table.cell(infoTable, 0, row, "Total Position", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 1, row, str.tostring(strategy.position_size) + " Lots", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 2, row, "@ " + str.tostring(close, "#.##"), bgcolor=color.new(color.purple, 80))
        row := row + 1

        // === V2 ENHANCED INFO: Pyramiding Logic Breakdown ===
        if pyramid_count < max_pyramids
            // Show pyramid gate status
            gate_color = pyramid_gated ? color.green : color.red
            table.cell(infoTable, 0, row, "Pyramid Gate", bgcolor=color.new(gate_color, 80))
            table.cell(infoTable, 1, row, pyramid_gated ? "✓ OPEN" : "✗ BLOCKED", bgcolor=color.new(gate_color, 80))
            table.cell(infoTable, 2, row, "Profit > Risk", bgcolor=color.new(gate_color, 80))
            row := row + 1

            // Show profit after base risk
            table.cell(infoTable, 0, row, "Base Risk", bgcolor=color.new(color.orange, 80))
            table.cell(infoTable, 1, row, "₹" + str.tostring(risk_long1/100000, "#.##") + "L", bgcolor=color.new(color.orange, 80))
            table.cell(infoTable, 2, row, "Long_1 Risk", bgcolor=color.new(color.orange, 80))
            row := row + 1

            table.cell(infoTable, 0, row, "Accum Profit", bgcolor=color.new(color.blue, 80))
            table.cell(infoTable, 1, row, "₹" + str.tostring(accumulated_profit/100000, "#.##") + "L", bgcolor=color.new(color.blue, 80))
            table.cell(infoTable, 2, row, "R+U Profit", bgcolor=color.new(color.blue, 80))
            row := row + 1

            table.cell(infoTable, 0, row, "Profit-Risk", bgcolor=color.new(color.teal, 80))
            table.cell(infoTable, 1, row, "₹" + str.tostring(profit_after_base_risk/100000, "#.##") + "L", bgcolor=color.new(color.teal, 80))
            table.cell(infoTable, 2, row, "Available", bgcolor=color.new(color.teal, 80))
            row := row + 1

            // Show lot-a, lot-b, lot-c breakdown
            table.cell(infoTable, 0, row, "Lot-A (Margin)", bgcolor=color.new(color.purple, 80))
            table.cell(infoTable, 1, row, str.tostring(pyramid_lot_a) + " lots", bgcolor=color.new(color.purple, 80))
            table.cell(infoTable, 2, row, "From Margin", bgcolor=color.new(color.purple, 80))
            row := row + 1

            table.cell(infoTable, 0, row, "Lot-B (50%)", bgcolor=color.new(color.purple, 80))
            table.cell(infoTable, 1, row, str.tostring(pyramid_lot_b) + " lots", bgcolor=color.new(color.purple, 80))
            table.cell(infoTable, 2, row, "Base × 50%", bgcolor=color.new(color.purple, 80))
            row := row + 1

            table.cell(infoTable, 0, row, "Lot-C (Risk)", bgcolor=color.new(color.purple, 80))
            table.cell(infoTable, 1, row, str.tostring(pyramid_lot_c) + " lots", bgcolor=color.new(color.purple, 80))
            table.cell(infoTable, 2, row, "From Budget", bgcolor=color.new(color.purple, 80))
            row := row + 1

        // Risk exposure
        risk_color = total_risk_exposure > current_equity * 0.05 ? color.red : color.orange
        table.cell(infoTable, 0, row, "Risk Exposure", bgcolor=color.new(risk_color, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(total_risk_exposure/100000, "#.##") + "L", bgcolor=color.new(risk_color, 80))
        table.cell(infoTable, 2, row, "If stopped out", bgcolor=color.new(risk_color, 80))
        row := row + 1

        // Open P&L
        unrealized_pnl_r = strategy.position_size > 0 ? unrealized_pnl / (current_equity * (risk_percent / 100)) : 0
        table.cell(infoTable, 0, row, "Open P&L", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(unrealized_pnl/100000, "#.##") + "L", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
        table.cell(infoTable, 2, row, str.tostring(unrealized_pnl_r, "#.##") + "R", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
        row := row + 1

        // Margin info
        margin_color = margin_utilization_pct > 90 ? color.red : (margin_utilization_pct > 75 ? color.orange : color.green)
        table.cell(infoTable, 0, row, "Margin Used", bgcolor=color.new(margin_color, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(current_margin_used_display, "#.#") + "L", bgcolor=color.new(margin_color, 80))
        table.cell(infoTable, 2, row, str.tostring(margin_utilization_pct, "#.#") + "%", bgcolor=color.new(margin_color, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Margin Free", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(margin_remaining, "#.#") + "L", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 2, row, str.tostring(pyramid_count) + "/" + str.tostring(max_pyramids) + " Pyrs", bgcolor=color.new(color.blue, 80))
        row := row + 1

    // === CAPITAL INFO (when flat or debug mode) ===
    if not in_position or show_all_info
        // Calculate position sizing for display (use same logic as actual entry)
        risk_amount = current_equity * (risk_percent / 100)
        risk_per_point = close - supertrend
        risk_per_lot = risk_per_point * lot_size
        risk_lots_preview = risk_per_lot > 0 ? (risk_amount / risk_per_lot) * er : 0
        risk_lots_preview_floored = math.floor(risk_lots_preview)
        margin_lots_preview = available_margin_lakhs > 0 ? math.floor(available_margin_lakhs / margin_per_lot) : 0
        final_lots_preview = math.max(0, math.min(risk_lots_preview_floored, margin_lots_preview))

        table.cell(infoTable, 0, row, "Current Equity", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(current_equity_lakhs, "#.#") + "L", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 2, row, "With Unrealized", bgcolor=color.new(color.blue, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Realized Equity", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(realized_equity_lakhs, "#.#") + "L", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 2, row, "Booked Only", bgcolor=color.new(color.purple, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Lot Size", bgcolor=color.new(color.orange, 80))
        table.cell(infoTable, 1, row, str.tostring(final_lots_preview) + " Lots", bgcolor=color.new(color.orange, 80))
        table.cell(infoTable, 2, row, "If entry now", bgcolor=color.new(color.orange, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Margin Avail", bgcolor=color.new(color.green, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(available_margin_lakhs, "#.#") + "L", bgcolor=color.new(color.green, 80))
        table.cell(infoTable, 2, row, use_leverage ? str.tostring(leverage_multiplier, "#.#") + "x Lev" : "Current Eq", bgcolor=color.new(color.green, 80))
        row := row + 1

// ========================================
// DEBUG PANEL - Shows condition states over time
// ========================================
// Plot all conditions (1 = true, 0 = false) in separate pane
// Display only when show_debug is enabled

plot(show_debug ? (rsi_condition ? 1 : 0) : na, "RSI>70", color=color.new(color.red, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (ema_condition ? 1 : 0) : na, "C>EMA", color=color.new(color.blue, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (dc_condition ? 1 : 0) : na, "C>DC", color=color.new(color.green, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (adx_condition ? 1 : 0) : na, "ADX<25", color=color.new(color.orange, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (er_condition ? 1 : 0) : na, "ER>0.8", color=color.new(color.purple, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (st_condition ? 1 : 0) : na, "C>ST", color=color.new(color.teal, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (not_doji ? 1 : 0) : na, "Not Doji", color=color.new(color.maroon, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (long_entry ? 7 : 0) : na, "ALL CONDITIONS", color=color.new(color.lime, 0), style=plot.style_columns, linewidth=3)
