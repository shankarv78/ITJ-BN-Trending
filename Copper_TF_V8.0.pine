//@version=5
// ========================================
// COPPER TREND FOLLOWING STRATEGY v8.0
// EOD PRE-CLOSE EXECUTION SYSTEM
// ========================================
//
// Version: v8.0
// Date: 2025-12-19 (Copper adaptation)
// Asset: MCX Copper Futures (2500 kg)
// Base Strategy: ITJ Trend Following V2 (with Triple-Constraint Pyramiding)
//
// COPPER CONTRACT SPECIFICATIONS:
// ========================================
// Contract: Copper (COPPER on MCX)
// Lot Size: 2,500 kg per contract
// Tick Size: Rs 0.05 per kg
// Point Value: Rs 125 per tick (0.05 × 2500)
//            : Rs 2,500 per Re 1 price move
// Margin: Rs 3,00,000 per lot (user specified)
// Trading Hours: 9:00 AM - 11:30 PM (14.5 hours)
// Settlement: Physical delivery
// Expiry: Last day of the month
//
// ADAPTED FROM: Silver Mini Trend Following Strategy v8.0
// ========================================

strategy("Copper Trend Following Strategy v8.0 (EOD PreClose)",
     overlay=true,
     pyramiding=3,
     initial_capital=5000000,
     default_qty_type=strategy.fixed,
     default_qty_value=1,
     calc_on_every_tick=false,
     calc_on_order_fills=false,
     process_orders_on_close=true,
     commission_type=strategy.commission.percent,
     commission_value=0.05,
     slippage=5)

// ========================================
// PARAMETERS
// ========================================

// RSI Parameters
rsi_period = input.int(6, "RSI Period", minval=1)
rsi_threshold = input.float(70, "RSI Overbought", minval=0, maxval=100, tooltip="Standard overbought level")
rsi_high_threshold = input.float(80, "RSI High Overbought", minval=0, maxval=100, tooltip="High overbought level (more extreme)")

// EMA Parameters
ema_period = input.int(50, "EMA Period", minval=1)

// Donchian Channel Parameters
dc_period = input.int(10, "DC Period", minval=1)

// ADX Parameters
adx_period = input.int(30, "ADX Period", minval=1)
adx_threshold = input.float(15, "ADX Threshold", minval=0, tooltip="v5.2: 15 (stricter trend filter, user-optimized)")

// Efficiency Ratio Parameters
er_period = input.int(3, "ER Period", minval=1, tooltip="v5.2: 3 (faster ER calculation, user-optimized)")
er_directional = input.bool(false, "ER Directional")
er_threshold = input.float(0.8, "ER Threshold", minval=0, maxval=1, tooltip="v5.2: 0.8 (stricter efficiency filter, user-optimized)")

// ROC (Rate of Change) Parameters
roc_period = input.int(15, "ROC Period", minval=1, tooltip="Rate of Change lookback period")
use_roc_for_pyramids = input.bool(true, "Use ROC Filter for Pyramids", tooltip="Copper-optimized: Enabled for pyramids")
roc_threshold = input.float(3.0, "ROC Threshold %", minval=-10, maxval=20, step=0.5, tooltip="Copper-optimized: 3%")

// SuperTrend Parameters
st_period = input.int(10, "ST Period", minval=1)
st_multiplier = input.float(1.5, "ST Multiplier", minval=0.1, step=0.1)

// Doji Detection Parameter
doji_threshold = input.float(0.1, "Doji Body/Range Ratio", minval=0.01, maxval=0.3, step=0.01, tooltip="Body size as % of candle range. Lower = stricter doji detection")

// Debug Mode
show_debug = input.bool(false, "Show Debug Panel", tooltip="Show detailed condition status in separate pane (not recommended - use info table instead)")

// Indicator Display Options
show_donchian = input.bool(false, "Show Donchian Channel", tooltip="Display DC upper/lower/middle bands on chart")
show_rsi = input.bool(false, "Show RSI", tooltip="Display RSI in separate pane")
show_adx = input.bool(false, "Show ADX", tooltip="Display ADX in separate pane")
show_er = input.bool(false, "Show Efficiency Ratio", tooltip="Display ER in separate pane")
show_atr = input.bool(false, "Show ATR", tooltip="Display ATR in separate pane")

// Info Panel Display Mode
show_info_panel = input.bool(true, "Show Info Panel", tooltip="Master toggle to show/hide the info panel", group="Info Panel")
smart_panel = input.bool(true, "Smart Info Panel", tooltip="Show indicators when flat, trade info when in position", group="Info Panel")
show_all_info = input.bool(false, "Show All Info (Debug)", tooltip="Show both indicators and trade info always (for debugging)", group="Info Panel")

// Position Sizing Parameters
risk_percent = input.float(2.0, "Risk % of Capital", minval=0.1, maxval=10, step=0.1, tooltip="Copper-optimized: 2% risk per trade")
lot_size = input.int(2500, "Point Value (Rs per Re 1 move)", minval=1, tooltip="Copper: Rs 2500 per Re 1 move (2500kg contract × Re 1/kg = Rs 2500)")

// Margin Management (Copper Futures)
use_margin_check = input.bool(true, "Enable Margin Check", tooltip="Prevent pyramiding if insufficient margin available")
margin_per_lot = input.float(3.0, "Margin per Lot (Lakhs)", minval=0.1, step=0.05, tooltip="Rs 3,00,000 per lot (MCX Copper margin requirement)")
use_leverage = input.bool(false, "Use Leverage", tooltip="Enable leverage for margin calculations")
leverage_multiplier = input.float(1.0, "Leverage Multiplier", minval=0.1, maxval=10, step=0.1, tooltip="Multiply available margin by this factor (1.0 = no leverage, 2.0 = 2x leverage)")

// Pyramiding Parameters
enable_pyramiding = input.bool(true, "Enable Pyramiding", tooltip="Allow adding to winning positions")
max_pyramids = input.int(3, "Max Pyramids", minval=1, maxval=5, tooltip="v5.2: 3 (more conservative, user-optimized)")
use_1r_gate = input.bool(true, "Use 1R Pyramid Gate", tooltip="Require price to move > 1R from entry before pyramiding. If disabled, only ATR spacing is required.")
atr_pyramid_threshold = input.float(0.75, "ATR Pyramid Threshold", minval=0.25, maxval=2.0, step=0.25, tooltip="Copper-optimized: 0.75 ATR spacing")
pyramid_size_ratio = input.float(0.5, "Pyramid Size Ratio", minval=0.25, maxval=1.0, step=0.05, tooltip="Size of each pyramid as ratio of previous entry (0.5 = 50%)")

// Stop Loss Management
stop_loss_mode = input.string("Tom Basso", "Stop Loss Mode", options=["SuperTrend", "Van Tharp", "Tom Basso"], tooltip="Tom Basso (recommended): Independent ATR trailing stops | SuperTrend: All entries use ST as SL | Van Tharp: Trail to breakeven")
atr_period_pyramid = input.int(10, "ATR Period (Pyramiding)", minval=1, tooltip="ATR period for calculating pyramid triggers")

// Tom Basso ATR Trailing Stop Parameters (only used if mode = "Tom Basso")
basso_initial_atr_mult = input.float(3.0, "Basso Initial Stop (× ATR)", minval=0.5, maxval=5.0, step=0.5, tooltip="Copper-optimized: 3× ATR initial stop")
basso_trailing_atr_mult = input.float(5.0, "Basso Trailing Stop (× ATR)", minval=1.0, maxval=10.0, step=0.5, tooltip="Copper-optimized: 5× ATR trailing stop")
basso_atr_period = input.int(10, "Basso ATR Period", minval=5, maxval=50, tooltip="ATR period for Tom Basso stop calculation")

// Trade Start Date Filter
use_start_date = input.bool(true, "Use Start Date Filter", tooltip="Only allow trades from specified date onwards")
start_date = input.time(timestamp("11 Nov 2025 00:00 +0000"), "Trade Start Date", tooltip="Strategy will only take trades from this date onwards")

// ========================================
// EOD PRE-CLOSE MONITORING SETTINGS
// ========================================
enable_eod_monitoring = input.bool(true, "Enable EOD Pre-Close Monitoring", group="EOD Settings", tooltip="Send EOD_MONITOR alerts during the last bar before market close for pre-close execution")

// ========================================
// INDICATOR CALCULATIONS
// ========================================

// RSI
rsi = ta.rsi(close, rsi_period)

// EMA
ema = ta.ema(close, ema_period)

// Donchian Channel (Upper band only for entry condition)
// Use [1] offset to check against PREVIOUS period's high, not including current bar
dc_upper = ta.highest(high[1], dc_period)
dc_lower = ta.lowest(low[1], dc_period)
dc_middle = (dc_upper + dc_lower) / 2

// ADX Calculation
[diPlus, diMinus, adx] = ta.dmi(adx_period, adx_period)

// Efficiency Ratio (Using exact code provided by user)
ER(src, p, dir) =>
    a = dir ? src - src[p] : math.abs(src - src[p])
    b = 0.0
    for i = 0 to p-1
        b := b + math.abs(src[i] - src[i+1])
    result = b != 0 ? a / b : 0
    result

er = ER(close, er_period, er_directional)

// SuperTrend (10, 1.5)
[supertrend, direction] = ta.supertrend(st_multiplier, st_period)

// ATR for Pyramiding
atr_pyramid = ta.atr(atr_period_pyramid)

// ATR for Tom Basso Mode
atr_basso = ta.atr(basso_atr_period)

// ROC (Rate of Change)
roc = ta.roc(close, roc_period)

// Doji Detection
// A doji has a very small body relative to the candle's range
body_size = math.abs(close - open)
candle_range = high - low
is_doji = candle_range > 0 ? (body_size / candle_range) <= doji_threshold : false

// ========================================
// STRATEGY CONDITIONS
// ========================================

// Entry Conditions (ALL must be true at candle close)
rsi_condition = rsi > rsi_threshold
ema_condition = close > ema
dc_condition = close > dc_upper
adx_condition = adx < adx_threshold
er_condition = er > er_threshold
st_condition = close > supertrend  // Price above SuperTrend (bullish)
not_doji = not is_doji  // Candle is NOT a doji

// Date Filter: Only allow trades from start_date onwards
date_filter = use_start_date ? time >= start_date : true

// Combine all conditions for long entry
long_entry = rsi_condition and ema_condition and dc_condition and adx_condition and er_condition and st_condition and not_doji and date_filter

// Exit Condition: Candle closes below SuperTrend
long_exit = close < supertrend

// EOD Detection: MCX Copper close varies by season (23:30 or 23:55 IST)
// Conservative approach: Flag EOD window from 23:00 onwards
is_eod_candle = hour(time) >= 23 and minute(time) >= 0
// EOD Alert Window: Last 5 minutes before close (23:25-23:30 for summer / 23:55 for winter)
// Used for EOD_MONITOR alerts - fires every tick, Python handles precise timing
is_eod_alert_window = hour(time) == 23 and minute(time) >= 25

// ========================================
// STRATEGY EXECUTION
// ========================================
// With process_orders_on_close=true:
// - Orders execute at the close of the current bar
// - This captures gap-ups/gap-downs
// - Entry price = close price of signal bar

// ========================================
// PYRAMIDING & POSITION MANAGEMENT
// ========================================
// v5.2: CAPITAL-INDEPENDENT PYRAMID GATE
// Pyramid gate now based on PRICE movement (1R), not accumulated profit
// This ensures same trend = same entries regardless of account size
// Note: 1R concept from Van Tharp, ATR stops from Tom Basso

var float equity_high = strategy.initial_capital  // Track highest equity reached
var float initial_entry_price = na  // First entry price (Long_1)
var float initial_stop_price = na   // v5.2: Initial stop at entry (for 1R calculation)
var float pyr1_entry_price = na  // Pyramid 1 entry price (Long_2)
var float pyr2_entry_price = na  // Pyramid 2 entry price (Long_3)
var float pyr3_entry_price = na  // Pyramid 3 entry price (Long_4)
var float pyr4_entry_price = na  // Pyramid 4 entry price (Long_5) - v5 extension
var float pyr5_entry_price = na  // Pyramid 5 entry price (Long_6) - v5 extension
var float last_pyramid_price = na  // Most recent pyramid entry price
var int pyramid_count = 0  // Number of pyramids added
var float initial_position_size = 0  // Size of first entry

// Tom Basso Mode: Track stops and highest close for each entry
var float basso_stop_long1 = na
var float basso_stop_long2 = na
var float basso_stop_long3 = na
var float basso_stop_long4 = na
var float basso_stop_long5 = na  // v5 extension
var float basso_stop_long6 = na  // v5 extension
var float highest_close_long1 = na
var float highest_close_long2 = na
var float highest_close_long3 = na
var float highest_close_long4 = na
var float highest_close_long5 = na  // v5 extension
var float highest_close_long6 = na  // v5 extension

// EQUITY TRACKING: Track both current and realized equity
current_equity = strategy.equity  // Includes both realized and unrealized P&L (for display and gate)

// V2 PROFIT LOCK-IN: Use equity_high (realized only) for position sizing
// This prevents compounding unrealized gains into new positions
realized_equity = strategy.initial_capital + strategy.netprofit
if realized_equity > equity_high
    equity_high := realized_equity

// Calculate unrealized profit from current open position
unrealized_pnl = strategy.openprofit
// R-multiple: How many times the initial risk we've made in profit
unrealized_pnl_r = strategy.position_size > 0 ? unrealized_pnl / (equity_high * (risk_percent / 100)) : 0

// V2: Accumulated Profit (for display purposes - no longer used for gate)
accumulated_profit = current_equity - strategy.initial_capital

// V2: Margin tracking uses CURRENT EQUITY (includes unrealized profits)
// Allows pyramiding based on current capital, not just realized
realized_equity_lakhs = realized_equity / 100000  // For reference
current_equity_lakhs = current_equity / 100000  // Primary for calculations
available_margin_lakhs = use_leverage ? current_equity_lakhs * leverage_multiplier : current_equity_lakhs
current_margin_used_display = strategy.position_size * margin_per_lot
margin_remaining = available_margin_lakhs - current_margin_used_display
margin_utilization_pct = available_margin_lakhs > 0 ? (current_margin_used_display / available_margin_lakhs) * 100 : 0

// Calculate stop loss levels and risk exposure for display
var float display_stop_long1 = na
var float display_stop_long2 = na
var float display_stop_long3 = na
var float display_stop_long4 = na
var float display_stop_long5 = na  // v5 extension
var float display_stop_long6 = na  // v5 extension

if strategy.position_size > 0
    if stop_loss_mode == "SuperTrend"
        // All positions use SuperTrend
        display_stop_long1 := not na(initial_entry_price) ? supertrend : na
        display_stop_long2 := not na(pyr1_entry_price) ? supertrend : na
        display_stop_long3 := not na(pyr2_entry_price) ? supertrend : na
        display_stop_long4 := not na(pyr3_entry_price) ? supertrend : na
        display_stop_long5 := not na(pyr4_entry_price) ? supertrend : na  // v5
        display_stop_long6 := not na(pyr5_entry_price) ? supertrend : na  // v5
    else if stop_loss_mode == "Van Tharp"
        // Trail to next pyramid or SuperTrend
        display_stop_long1 := not na(initial_entry_price) ? (not na(pyr1_entry_price) ? pyr1_entry_price : supertrend) : na
        display_stop_long2 := not na(pyr1_entry_price) ? (not na(pyr2_entry_price) ? pyr2_entry_price : supertrend) : na
        display_stop_long3 := not na(pyr2_entry_price) ? (not na(pyr3_entry_price) ? pyr3_entry_price : supertrend) : na
        display_stop_long4 := not na(pyr3_entry_price) ? (not na(pyr4_entry_price) ? pyr4_entry_price : supertrend) : na  // v5
        display_stop_long5 := not na(pyr4_entry_price) ? (not na(pyr5_entry_price) ? pyr5_entry_price : supertrend) : na  // v5
        display_stop_long6 := not na(pyr5_entry_price) ? supertrend : na  // v5
    else if stop_loss_mode == "Tom Basso"
        // Individual ATR trailing stops
        display_stop_long1 := basso_stop_long1
        display_stop_long2 := basso_stop_long2
        display_stop_long3 := basso_stop_long3
        display_stop_long4 := basso_stop_long4
        display_stop_long5 := basso_stop_long5  // v5
        display_stop_long6 := basso_stop_long6  // v5

// Calculate risk exposure per position (if stopped out)
risk_long1 = not na(initial_entry_price) and not na(display_stop_long1) ? math.max(0, (initial_entry_price - display_stop_long1) * initial_position_size * lot_size) : 0
risk_long2 = not na(pyr1_entry_price) and not na(display_stop_long2) ? math.max(0, (pyr1_entry_price - display_stop_long2) * initial_position_size * pyramid_size_ratio * lot_size) : 0
risk_long3 = not na(pyr2_entry_price) and not na(display_stop_long3) ? math.max(0, (pyr2_entry_price - display_stop_long3) * initial_position_size * math.pow(pyramid_size_ratio, 2) * lot_size) : 0
risk_long4 = not na(pyr3_entry_price) and not na(display_stop_long4) ? math.max(0, (pyr3_entry_price - display_stop_long4) * initial_position_size * math.pow(pyramid_size_ratio, 3) * lot_size) : 0
risk_long5 = not na(pyr4_entry_price) and not na(display_stop_long5) ? math.max(0, (pyr4_entry_price - display_stop_long5) * initial_position_size * math.pow(pyramid_size_ratio, 4) * lot_size) : 0  // v5
risk_long6 = not na(pyr5_entry_price) and not na(display_stop_long6) ? math.max(0, (pyr5_entry_price - display_stop_long6) * initial_position_size * math.pow(pyramid_size_ratio, 5) * lot_size) : 0  // v5
total_risk_exposure = risk_long1 + risk_long2 + risk_long3 + risk_long4 + risk_long5 + risk_long6  // v5

// V2: Dynamic Base Risk (recalculates as stop trails) - kept for display
base_risk = risk_long1

// INITIAL ENTRY: When all conditions are met and no position exists
if long_entry and strategy.position_size == 0
    // V2 PROFIT LOCK-IN: Calculate risk amount using realized equity only
    // Prevents compounding unrealized gains into new positions
    risk_amount = equity_high * (risk_percent / 100)

    // Entry price and stop
    entry_price = close
    stop_loss = supertrend

    // Risk per lot in points and rupees
    risk_per_point = entry_price - stop_loss
    risk_per_lot = risk_per_point * lot_size

    // Calculate number of lots based on RISK: (Risk ÷ ((Entry - ST) × Lot_Size)) × ER
    risk_based_lots = risk_per_lot > 0 ? (risk_amount / risk_per_lot) * er : 0
    risk_based_lots_floored = math.floor(risk_based_lots)  // Always round DOWN

    // Calculate max lots based on AVAILABLE MARGIN
    margin_based_lots = available_margin_lakhs > 0 ? math.floor(available_margin_lakhs / margin_per_lot) : 0

    // Take MINIMUM of risk-based and margin-based (ensures we never exceed available margin)
    // Both are floored, so final_lots will NEVER exceed available margin
    // Ensure result is valid (0 if less than 1 lot affordable)
    final_lots = math.max(0, math.min(risk_based_lots_floored, margin_based_lots))

    // Only enter if we can afford at least 1 lot
    if final_lots >= 1
        // Store initial entry details
        initial_entry_price := close
        last_pyramid_price := close
        pyramid_count := 0
        initial_position_size := final_lots

        // v5.2: Store initial stop for 1R calculation (capital-independent gate)
        if stop_loss_mode == "Tom Basso"
            initial_stop_price := close - (basso_initial_atr_mult * atr_basso)
            basso_stop_long1 := initial_stop_price
            highest_close_long1 := close
        else
            initial_stop_price := supertrend

        // Enter with calculated lot size
        entry_comment = "ENTRY-" + str.tostring(final_lots) + "L"
        strategy.entry("Long_1", strategy.long, qty=final_lots, comment=entry_comment)

        // JSON Alert for BASE_ENTRY
        // Use mode-specific stop: Tom Basso uses ATR-based stop, others use SuperTrend
        float alert_stop = stop_loss_mode == "Tom Basso" ? initial_stop_price : supertrend
        timestamp_str = str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)
        json_entry = '{"type":"BASE_ENTRY", "instrument":"COPPER", "position":"Long_1", "price":' + str.tostring(close) + ', "stop":' + str.tostring(alert_stop) + ', "lots":' + str.tostring(final_lots) + ', "atr":' + str.tostring(atr_pyramid) + ', "er":' + str.tostring(er) + ', "supertrend":' + str.tostring(supertrend) + ', "roc":' + str.tostring(roc) + ', "timestamp":"' + timestamp_str + '"}'
        alert(json_entry, alert.freq_once_per_bar_close)

// v5.2: Initialize lot constraint variables at appropriate scope for info panel access
float lot_a = 0.0
float lot_b = 0.0
float lot_c = 0.0
float pyramid_lots = 0.0

// v5.2: Calculate price-based pyramid gate values (for display and logic)
float initial_risk_points = not na(initial_entry_price) and not na(initial_stop_price) ? initial_entry_price - initial_stop_price : 0.0
float price_move_from_entry = not na(initial_entry_price) ? close - initial_entry_price : 0.0
float price_move_in_r = initial_risk_points > 0 ? price_move_from_entry / initial_risk_points : 0.0

// v5.2: Calculate pyramid gate status at global scope (for info panel display)
// Gate: Price must move by at least 1R (initial risk distance in points)
// Can be disabled via use_1r_gate flag (then only ATR spacing required)
bool pyramid_gate_open = use_1r_gate ? (price_move_from_entry > initial_risk_points) : true

// Calculate ATR moves from last pyramid (for display and logic)
float price_move_from_last = not na(last_pyramid_price) ? close - last_pyramid_price : 0.0
float atr_moves_from_last = atr_pyramid > 0 ? price_move_from_last / atr_pyramid : 0.0

// PYRAMIDING: v5.2 CAPITAL-INDEPENDENT Gate + Triple-Constraint Sizing
// Gate is now PRICE-BASED: price must move by at least 1R (initial risk in points)
if enable_pyramiding and strategy.position_size > 0 and pyramid_count < max_pyramids

    // ROC momentum check (optional filter for pyramids)
    roc_ok_for_pyramid = use_roc_for_pyramids ? roc > roc_threshold : true

    // ========================================
    // TRIPLE CONSTRAINT SIZING (Capital-dependent - correct!)
    // ========================================
    if pyramid_gate_open and atr_moves_from_last >= atr_pyramid_threshold and roc_ok_for_pyramid
        // CONSTRAINT 1: lot-a (Margin Safety)
        // Maximum lots affordable based on available margin
        current_margin_used = strategy.position_size * margin_per_lot
        free_margin = available_margin_lakhs - current_margin_used
        lot_a := free_margin > 0 ? math.floor(free_margin / margin_per_lot) : 0

        // CONSTRAINT 2: lot-b (Discipline Safety)
        // Maintain 50% geometric scaling from base position
        lot_b := math.floor(initial_position_size * 0.5)

        // CONSTRAINT 3: lot-c (Profit Safety)
        // Only risk 50% of excess profit (profit beyond base risk)
        profit_after_base_risk = accumulated_profit - base_risk
        available_risk_budget = math.max(0, profit_after_base_risk * 0.5)

        // Calculate risk per lot for this pyramid
        pyramid_stop = stop_loss_mode == "SuperTrend" ? supertrend : (stop_loss_mode == "Tom Basso" ? (not na(basso_stop_long1) ? basso_stop_long1 : supertrend) : supertrend)
        pyramid_stop_distance = close - pyramid_stop
        risk_per_lot_pyramid = pyramid_stop_distance * lot_size

        // Calculate lot-c (with zero protection)
        lot_c := risk_per_lot_pyramid > 0 ? math.floor(available_risk_budget / risk_per_lot_pyramid) : 0

        // FINAL PYRAMID SIZE: Minimum of all three constraints
        pyramid_lots := math.min(lot_a, math.min(lot_b, lot_c))
        pyramid_lots := math.max(0, pyramid_lots)  // Ensure non-negative
    // Note: If gate closed or conditions not met, variables remain at initial 0 values

    // Trigger: Gate open AND price moved AND ROC OK AND >= 1 lot
    pyramid_trigger = pyramid_gate_open and atr_moves_from_last >= atr_pyramid_threshold and roc_ok_for_pyramid and pyramid_lots >= 1

    if pyramid_trigger

        // Update tracking
        pyramid_count := pyramid_count + 1
        last_pyramid_price := close

        // Track individual pyramid entry prices (for Van Tharp mode)
        if pyramid_count == 1
            pyr1_entry_price := close
            // Initialize Tom Basso stop for Long_2
            if stop_loss_mode == "Tom Basso"
                basso_stop_long2 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long2 := close
        else if pyramid_count == 2
            pyr2_entry_price := close
            // Initialize Tom Basso stop for Long_3
            if stop_loss_mode == "Tom Basso"
                basso_stop_long3 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long3 := close
        else if pyramid_count == 3
            pyr3_entry_price := close
            // Initialize Tom Basso stop for Long_4
            if stop_loss_mode == "Tom Basso"
                basso_stop_long4 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long4 := close
        else if pyramid_count == 4
            pyr4_entry_price := close  // v5 extension
            // Initialize Tom Basso stop for Long_5
            if stop_loss_mode == "Tom Basso"
                basso_stop_long5 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long5 := close
        else if pyramid_count == 5
            pyr5_entry_price := close  // v5 extension
            // Initialize Tom Basso stop for Long_6
            if stop_loss_mode == "Tom Basso"
                basso_stop_long6 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long6 := close

        // Enter pyramid
        strategy.entry("Long_" + str.tostring(pyramid_count + 1), strategy.long, qty=pyramid_lots, comment="PYR" + str.tostring(pyramid_count) + "-" + str.tostring(pyramid_lots) + "L")

        // JSON Alert for PYRAMID
        timestamp_str = str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)
        pyramid_stop = stop_loss_mode == "SuperTrend" ? supertrend : (stop_loss_mode == "Tom Basso" ? (not na(basso_stop_long1) ? basso_stop_long1 : supertrend) : supertrend)
        json_pyramid = '{"type":"PYRAMID", "instrument":"COPPER", "position":"Long_' + str.tostring(pyramid_count + 1) + '", "price":' + str.tostring(close) + ', "stop":' + str.tostring(pyramid_stop) + ', "lots":' + str.tostring(pyramid_lots) + ', "atr":' + str.tostring(atr_pyramid) + ', "er":' + str.tostring(er) + ', "supertrend":' + str.tostring(supertrend) + ', "roc":' + str.tostring(roc) + ', "timestamp":"' + timestamp_str + '"}'
        alert(json_pyramid, alert.freq_once_per_bar_close)

// STOP LOSS MANAGEMENT
if strategy.position_size > 0
    if stop_loss_mode == "SuperTrend"
        // ========================================
        // Mode 1: SuperTrend (Simple)
        // ========================================
        // All positions use SuperTrend as stop
        // ONLY check at bar close (not on every tick) to avoid premature exits
        if close < supertrend and barstate.isconfirmed
            // Capture position size before closing
            exit_lots = strategy.position_size
            // JSON Alert for SuperTrend Exit
            timestamp_str = str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)
            json_exit = '{"type":"EXIT", "instrument":"COPPER", "position":"ALL", "price":' + str.tostring(close) + ', "stop":' + str.tostring(supertrend) + ', "entry_price":' + str.tostring(initial_entry_price) + ', "lots":' + str.tostring(exit_lots) + ', "reason":"SuperTrend", "atr":' + str.tostring(atr_pyramid) + ', "er":' + str.tostring(er) + ', "supertrend":' + str.tostring(supertrend) + ', "roc":' + str.tostring(roc) + ', "timestamp":"' + timestamp_str + '"}'
            alert(json_exit, alert.freq_once_per_bar_close)
            strategy.close_all(comment="EXIT - Below ST")
            // Reset tracking
            initial_entry_price := na
            initial_stop_price := na  // v5.2
            pyr1_entry_price := na
            pyr2_entry_price := na
            pyr3_entry_price := na
            pyr4_entry_price := na  // v5
            pyr5_entry_price := na  // v5
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

    else if stop_loss_mode == "Van Tharp"
        // ========================================
        // Mode 2: Van Tharp (Trail to Breakeven)
        // ========================================
        // Trail earlier pyramid entries to the entry price of later pyramids
        // Check each position independently (not based on pyramid_count)
        // ONLY check at bar close (not on every tick) to avoid premature exits

        // Long_1 (Initial Entry): Trail to PYR1 or SuperTrend
        if not na(initial_entry_price) and barstate.isconfirmed
            if not na(pyr1_entry_price)
                // PYR1 exists above us, trail to it
                if close < pyr1_entry_price
                    strategy.close("Long_1", comment="EXIT - Trail to PYR1")
                    initial_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_1", comment="EXIT - Below ST")
                    initial_entry_price := na

        // Long_2 (PYR1): Trail to PYR2 or SuperTrend
        if not na(pyr1_entry_price) and barstate.isconfirmed
            if not na(pyr2_entry_price)
                // PYR2 exists above us, trail to it
                if close < pyr2_entry_price
                    strategy.close("Long_2", comment="EXIT - Trail to PYR2")
                    pyr1_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_2", comment="EXIT - Below ST")
                    pyr1_entry_price := na

        // Long_3 (PYR2): Trail to PYR3 or SuperTrend
        if not na(pyr2_entry_price) and barstate.isconfirmed
            if not na(pyr3_entry_price)
                // PYR3 exists above us, trail to it
                if close < pyr3_entry_price
                    strategy.close("Long_3", comment="EXIT - Trail to PYR3")
                    pyr2_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_3", comment="EXIT - Below ST")
                    pyr2_entry_price := na

        // Long_4 (PYR3): Trail to PYR4 or SuperTrend (v5 updated)
        if not na(pyr3_entry_price) and barstate.isconfirmed
            if not na(pyr4_entry_price)
                // PYR4 exists above us, trail to it
                if close < pyr4_entry_price
                    strategy.close("Long_4", comment="EXIT - Trail to PYR4")
                    pyr3_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_4", comment="EXIT - Below ST")
                    pyr3_entry_price := na

        // Long_5 (PYR4): Trail to PYR5 or SuperTrend (v5 extension)
        if not na(pyr4_entry_price) and barstate.isconfirmed
            if not na(pyr5_entry_price)
                // PYR5 exists above us, trail to it
                if close < pyr5_entry_price
                    strategy.close("Long_5", comment="EXIT - Trail to PYR5")
                    pyr4_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_5", comment="EXIT - Below ST")
                    pyr4_entry_price := na

        // Long_6 (PYR5): Always trail to SuperTrend (highest level) (v5 extension)
        if not na(pyr5_entry_price) and barstate.isconfirmed
            if close < supertrend
                strategy.close("Long_6", comment="EXIT - Below ST")
                pyr5_entry_price := na

        // If all positions closed, reset everything
        if strategy.position_size == 0
            initial_entry_price := na
            initial_stop_price := na  // v5.2
            pyr1_entry_price := na
            pyr2_entry_price := na
            pyr3_entry_price := na
            pyr4_entry_price := na  // v5
            pyr5_entry_price := na  // v5
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

    else if stop_loss_mode == "Tom Basso"
        // ========================================
        // Mode 3: Tom Basso ATR Trailing Stop
        // ========================================
        // Each position has its own ATR-based trailing stop
        // Stop = max(Initial Stop, Highest Close - Trailing ATR)
        // Using manual tracking instead of ta.highest() to avoid buffer issues
        // ONLY check at bar close (not on every tick) to avoid premature exits

        // Update trailing stops for each position
        // Long_1 (Initial Entry)
        if not na(initial_entry_price)
            // Update highest close since entry (on every tick to track the highest)
            highest_close_long1 := math.max(highest_close_long1, close)
            // Calculate trailing stop
            trailing_stop_long1 = highest_close_long1 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long1 := math.max(basso_stop_long1, trailing_stop_long1)  // Only move up

            // Exit Long_1 if close below trailing stop (ONLY at bar close)
            if close < basso_stop_long1 and barstate.isconfirmed
                strategy.close("Long_1", comment="EXIT - Basso Stop")
                // JSON Alert for Long_1 Exit
                timestamp_str = str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)
                json_exit_l1 = '{"type":"EXIT", "instrument":"COPPER", "position":"Long_1", "price":' + str.tostring(close) + ', "stop":' + str.tostring(basso_stop_long1) + ', "entry_price":' + str.tostring(initial_entry_price) + ', "lots":' + str.tostring(initial_position_size) + ', "reason":"TOM_BASSO_STOP", "atr":' + str.tostring(atr_basso) + ', "er":' + str.tostring(er) + ', "supertrend":' + str.tostring(supertrend) + ', "roc":' + str.tostring(roc) + ', "timestamp":"' + timestamp_str + '"}'
                alert(json_exit_l1, alert.freq_once_per_bar_close)
                initial_entry_price := na
                basso_stop_long1 := na
                highest_close_long1 := na

        // Long_2 (PYR1)
        if not na(pyr1_entry_price)
            highest_close_long2 := math.max(highest_close_long2, close)
            trailing_stop_long2 = highest_close_long2 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long2 := math.max(basso_stop_long2, trailing_stop_long2)

            if close < basso_stop_long2 and barstate.isconfirmed
                strategy.close("Long_2", comment="EXIT - Basso Stop")
                // JSON Alert for Long_2 Exit
                timestamp_str = str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)
                pyr1_lots_exit = math.round(initial_position_size * pyramid_size_ratio)
                json_exit_l2 = '{"type":"EXIT", "instrument":"COPPER", "position":"Long_2", "price":' + str.tostring(close) + ', "stop":' + str.tostring(basso_stop_long2) + ', "entry_price":' + str.tostring(pyr1_entry_price) + ', "lots":' + str.tostring(pyr1_lots_exit) + ', "reason":"TOM_BASSO_STOP", "atr":' + str.tostring(atr_basso) + ', "er":' + str.tostring(er) + ', "supertrend":' + str.tostring(supertrend) + ', "roc":' + str.tostring(roc) + ', "timestamp":"' + timestamp_str + '"}'
                alert(json_exit_l2, alert.freq_once_per_bar_close)
                pyr1_entry_price := na
                basso_stop_long2 := na
                highest_close_long2 := na

        // Long_3 (PYR2)
        if not na(pyr2_entry_price)
            highest_close_long3 := math.max(highest_close_long3, close)
            trailing_stop_long3 = highest_close_long3 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long3 := math.max(basso_stop_long3, trailing_stop_long3)

            if close < basso_stop_long3 and barstate.isconfirmed
                strategy.close("Long_3", comment="EXIT - Basso Stop")
                // JSON Alert for Long_3 Exit
                timestamp_str = str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)
                pyr2_lots_exit = math.round(initial_position_size * math.pow(pyramid_size_ratio, 2))
                json_exit_l3 = '{"type":"EXIT", "instrument":"COPPER", "position":"Long_3", "price":' + str.tostring(close) + ', "stop":' + str.tostring(basso_stop_long3) + ', "entry_price":' + str.tostring(pyr2_entry_price) + ', "lots":' + str.tostring(pyr2_lots_exit) + ', "reason":"TOM_BASSO_STOP", "atr":' + str.tostring(atr_basso) + ', "er":' + str.tostring(er) + ', "supertrend":' + str.tostring(supertrend) + ', "roc":' + str.tostring(roc) + ', "timestamp":"' + timestamp_str + '"}'
                alert(json_exit_l3, alert.freq_once_per_bar_close)
                pyr2_entry_price := na
                basso_stop_long3 := na
                highest_close_long3 := na

        // Long_4 (PYR3)
        if not na(pyr3_entry_price)
            highest_close_long4 := math.max(highest_close_long4, close)
            trailing_stop_long4 = highest_close_long4 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long4 := math.max(basso_stop_long4, trailing_stop_long4)

            if close < basso_stop_long4 and barstate.isconfirmed
                strategy.close("Long_4", comment="EXIT - Basso Stop")
                // JSON Alert for Long_4 Exit
                timestamp_str = str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)
                pyr3_lots_exit = math.round(initial_position_size * math.pow(pyramid_size_ratio, 3))
                json_exit_l4 = '{"type":"EXIT", "instrument":"COPPER", "position":"Long_4", "price":' + str.tostring(close) + ', "stop":' + str.tostring(basso_stop_long4) + ', "entry_price":' + str.tostring(pyr3_entry_price) + ', "lots":' + str.tostring(pyr3_lots_exit) + ', "reason":"TOM_BASSO_STOP", "atr":' + str.tostring(atr_basso) + ', "er":' + str.tostring(er) + ', "supertrend":' + str.tostring(supertrend) + ', "roc":' + str.tostring(roc) + ', "timestamp":"' + timestamp_str + '"}'
                alert(json_exit_l4, alert.freq_once_per_bar_close)
                pyr3_entry_price := na
                basso_stop_long4 := na
                highest_close_long4 := na

        // Long_5 (PYR4) - v5 extension
        if not na(pyr4_entry_price)
            highest_close_long5 := math.max(highest_close_long5, close)
            trailing_stop_long5 = highest_close_long5 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long5 := math.max(basso_stop_long5, trailing_stop_long5)

            if close < basso_stop_long5 and barstate.isconfirmed
                strategy.close("Long_5", comment="EXIT - Basso Stop")
                // JSON Alert for Long_5 Exit
                timestamp_str = str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)
                pyr4_lots_exit = math.round(initial_position_size * math.pow(pyramid_size_ratio, 4))
                json_exit_l5 = '{"type":"EXIT", "instrument":"COPPER", "position":"Long_5", "price":' + str.tostring(close) + ', "stop":' + str.tostring(basso_stop_long5) + ', "entry_price":' + str.tostring(pyr4_entry_price) + ', "lots":' + str.tostring(pyr4_lots_exit) + ', "reason":"TOM_BASSO_STOP", "atr":' + str.tostring(atr_basso) + ', "er":' + str.tostring(er) + ', "supertrend":' + str.tostring(supertrend) + ', "roc":' + str.tostring(roc) + ', "timestamp":"' + timestamp_str + '"}'
                alert(json_exit_l5, alert.freq_once_per_bar_close)
                pyr4_entry_price := na
                basso_stop_long5 := na
                highest_close_long5 := na

        // Long_6 (PYR5) - v5 extension
        if not na(pyr5_entry_price)
            highest_close_long6 := math.max(highest_close_long6, close)
            trailing_stop_long6 = highest_close_long6 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long6 := math.max(basso_stop_long6, trailing_stop_long6)

            if close < basso_stop_long6 and barstate.isconfirmed
                strategy.close("Long_6", comment="EXIT - Basso Stop")
                // JSON Alert for Long_6 Exit
                timestamp_str = str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)
                pyr5_lots_exit = math.round(initial_position_size * math.pow(pyramid_size_ratio, 5))
                json_exit_l6 = '{"type":"EXIT", "instrument":"COPPER", "position":"Long_6", "price":' + str.tostring(close) + ', "stop":' + str.tostring(basso_stop_long6) + ', "entry_price":' + str.tostring(pyr5_entry_price) + ', "lots":' + str.tostring(pyr5_lots_exit) + ', "reason":"TOM_BASSO_STOP", "atr":' + str.tostring(atr_basso) + ', "er":' + str.tostring(er) + ', "supertrend":' + str.tostring(supertrend) + ', "roc":' + str.tostring(roc) + ', "timestamp":"' + timestamp_str + '"}'
                alert(json_exit_l6, alert.freq_once_per_bar_close)
                pyr5_entry_price := na
                basso_stop_long6 := na
                highest_close_long6 := na

        // If all positions closed, reset
        if strategy.position_size == 0
            initial_stop_price := na  // v5.2
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

// ========================================
// PLOTTING
// ========================================

// Always plot EMA and SuperTrend on main chart
plot(ema, "EMA 200", color=color.blue, linewidth=2, force_overlay=true)
plot(supertrend, "SuperTrend (10,1.5)", color=direction < 0 ? color.new(color.green, 0) : color.new(color.red, 0), linewidth=2, style=plot.style_line, force_overlay=true)

// Tom Basso Trailing Stop Losses (only show when active)
plot(stop_loss_mode == "Tom Basso" and not na(basso_stop_long1) ? basso_stop_long1 : na, "Basso SL 1", color=color.new(color.red, 0), linewidth=2, style=plot.style_circles, force_overlay=true)
plot(stop_loss_mode == "Tom Basso" and not na(basso_stop_long2) ? basso_stop_long2 : na, "Basso SL 2", color=color.new(color.orange, 0), linewidth=2, style=plot.style_circles, force_overlay=true)
plot(stop_loss_mode == "Tom Basso" and not na(basso_stop_long3) ? basso_stop_long3 : na, "Basso SL 3", color=color.new(color.yellow, 0), linewidth=2, style=plot.style_circles, force_overlay=true)
plot(stop_loss_mode == "Tom Basso" and not na(basso_stop_long4) ? basso_stop_long4 : na, "Basso SL 4", color=color.new(color.purple, 0), linewidth=2, style=plot.style_circles, force_overlay=true)
plot(stop_loss_mode == "Tom Basso" and not na(basso_stop_long5) ? basso_stop_long5 : na, "Basso SL 5", color=color.new(color.fuchsia, 0), linewidth=2, style=plot.style_circles, force_overlay=true)
plot(stop_loss_mode == "Tom Basso" and not na(basso_stop_long6) ? basso_stop_long6 : na, "Basso SL 6", color=color.new(color.maroon, 0), linewidth=2, style=plot.style_circles, force_overlay=true)

// Optional: Donchian Channel on main chart
plot(show_donchian ? dc_upper : na, "DC Upper", color=color.new(color.green, 0), linewidth=1, style=plot.style_line, force_overlay=true)
plot(show_donchian ? dc_lower : na, "DC Lower", color=color.new(color.red, 0), linewidth=1, style=plot.style_line, force_overlay=true)
plot(show_donchian ? dc_middle : na, "DC Middle", color=color.new(color.gray, 50), linewidth=1, style=plot.style_circles, force_overlay=true)

// Optional: RSI (separate pane - different scale from price)
plot(show_rsi ? rsi : na, "RSI(6)", color=color.new(color.purple, 0), linewidth=2)
hline(show_rsi ? 70 : na, "RSI 70", color=color.new(color.red, 50), linestyle=hline.style_dashed)
hline(show_rsi ? 30 : na, "RSI 30", color=color.new(color.green, 50), linestyle=hline.style_dashed)
hline(show_rsi ? 50 : na, "RSI 50", color=color.new(color.gray, 70), linestyle=hline.style_dotted)

// Optional: ADX (separate pane - different scale from price)
plot(show_adx ? adx : na, "ADX(30)", color=color.new(color.orange, 0), linewidth=2)
hline(show_adx ? 25 : na, "ADX 25", color=color.new(color.orange, 50), linestyle=hline.style_dashed)
hline(show_adx ? 50 : na, "ADX 50", color=color.new(color.red, 50), linestyle=hline.style_dotted)

// Optional: Efficiency Ratio (separate pane - different scale from price)
plot(show_er ? er : na, "ER(3)", color=color.new(color.blue, 0), linewidth=2)
hline(show_er ? 0.8 : na, "ER 0.8", color=color.new(color.green, 50), linestyle=hline.style_dashed)
hline(show_er ? 0.5 : na, "ER 0.5", color=color.new(color.gray, 50), linestyle=hline.style_dotted)
hline(show_er ? 0 : na, "ER 0", color=color.new(color.gray, 70), linestyle=hline.style_solid)

// Optional: ATR (separate pane - different scale from price)
plot(show_atr ? atr_pyramid : na, "ATR(10)", color=color.new(color.maroon, 0), linewidth=2)

// Visual markers for entries and exits - SMALL ARROWS at bar close (on main chart)
plotshape(long_entry and strategy.position_size == 0,
     title="Entry Signal",
     location=location.belowbar,
     color=color.new(color.lime, 0),
     style=shape.arrowup,
     size=size.tiny,
     text="",
     force_overlay=true)

plotshape(long_exit and strategy.position_size > 0,
     title="Exit Signal",
     location=location.abovebar,
     color=color.new(color.red, 0),
     style=shape.arrowdown,
     size=size.tiny,
     text="",
     force_overlay=true)

// ========================================
// SMART INFO PANEL - Context-Aware Display (v5.2 Enhanced)
// ========================================

var table infoTable = table.new(position.top_right, 3, 50, border_width=2, bgcolor=color.new(color.white, 0), frame_color=color.black, frame_width=2)

// Smart Info Panel - Context-Aware Display
// Update on every bar to ensure immediate visibility when script loads
if show_info_panel
    // Clear the table first to avoid stale data
    table.clear(infoTable, 0, 0, 2, 49)

    // Determine what to show based on position status
    // Use entry price tracking for more accurate real-time position status
    // (strategy.position_size only updates at bar close)
    in_position = not na(initial_entry_price) or not na(pyr1_entry_price) or not na(pyr2_entry_price) or not na(pyr3_entry_price) or not na(pyr4_entry_price) or not na(pyr5_entry_price)
    show_indicators = (smart_panel and not in_position) or show_all_info
    show_trade_info = (smart_panel and in_position) or show_all_info

    // Header
    table.cell(infoTable, 0, 0, in_position ? "Position" : "Indicator", bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(infoTable, 1, 0, "Value", bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(infoTable, 2, 0, "Status", bgcolor=color.gray, text_color=color.white, text_size=size.normal)

    row = 1

    // === INDICATOR SECTION (when flat or debug mode) ===
    if show_indicators
        table.cell(infoTable, 0, row, "Close")
        table.cell(infoTable, 1, row, str.tostring(close, "#.##"))
        table.cell(infoTable, 2, row, "Current Price")
        row := row + 1

        table.cell(infoTable, 0, row, "RSI(6)")
        table.cell(infoTable, 1, row, str.tostring(rsi, "#.##"))
        table.cell(infoTable, 2, row, rsi_condition ? "✓ >70" : "✗ " + str.tostring(rsi, "#.##"), text_color=rsi_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "EMA(200)")
        table.cell(infoTable, 1, row, str.tostring(ema, "#.##"))
        table.cell(infoTable, 2, row, ema_condition ? "✓ Above" : "✗ Below", text_color=ema_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "DC Upper")
        table.cell(infoTable, 1, row, str.tostring(dc_upper, "#.##"))
        table.cell(infoTable, 2, row, dc_condition ? "✓ Above" : "✗ Below", text_color=dc_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "ADX(30)")
        table.cell(infoTable, 1, row, str.tostring(adx, "#.##"))
        table.cell(infoTable, 2, row, adx_condition ? "✓ <15" : "✗ " + str.tostring(adx, "#.##"), text_color=adx_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "ER(3)")
        table.cell(infoTable, 1, row, str.tostring(er, "#.####"))
        table.cell(infoTable, 2, row, er_condition ? "✓ >0.8" : "✗ " + str.tostring(er, "#.####"), text_color=er_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "SuperTrend")
        table.cell(infoTable, 1, row, str.tostring(supertrend, "#.##"))
        table.cell(infoTable, 2, row, st_condition ? "✓ Above" : "✗ Below", text_color=st_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "Doji Check")
        table.cell(infoTable, 1, row, candle_range > 0 ? str.tostring(body_size/candle_range, "#.###") : "N/A")
        table.cell(infoTable, 2, row, not_doji ? "✓ Not Doji" : "✗ Is Doji", text_color=not_doji ? color.green : color.red)
        row := row + 1

    // === ENTRY SIGNAL (always show) ===
    table.cell(infoTable, 0, row, "ENTRY SIGNAL", bgcolor=long_entry ? color.new(color.green, 70) : color.new(color.red, 70))
    table.cell(infoTable, 1, row, long_entry ? "✓ ALL MET" : "✗ WAITING", text_color=color.white, bgcolor=long_entry ? color.new(color.green, 50) : color.new(color.red, 50))
    table.cell(infoTable, 2, row, in_position ? "IN TRADE" : "NO POSITION", text_color=color.white, bgcolor=in_position ? color.new(color.blue, 50) : color.new(color.gray, 50))
    row := row + 1

    // === TRADE INFO SECTION (when in position or debug mode) ===
    if show_trade_info
        // Position entries and stops with ENHANCED trailing SL display
        if not na(initial_entry_price)
            entry_lots = math.round(initial_position_size)
            trail_info_1 = stop_loss_mode == "Tom Basso" and not na(highest_close_long1) ? " | Hi:" + str.tostring(highest_close_long1, "#") : ""

            table.cell(infoTable, 0, row, "Long_1 Entry", bgcolor=color.new(color.blue, 80))
            table.cell(infoTable, 1, row, str.tostring(initial_entry_price, "#.##") + " (" + str.tostring(entry_lots) + "L)", bgcolor=color.new(color.blue, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long1, "#.##") + trail_info_1, bgcolor=color.new(color.blue, 80))
            row := row + 1

        if not na(pyr1_entry_price)
            pyr1_lots = math.round(initial_position_size * pyramid_size_ratio)
            trail_info_2 = stop_loss_mode == "Tom Basso" and not na(highest_close_long2) ? " | Hi:" + str.tostring(highest_close_long2, "#") : ""

            table.cell(infoTable, 0, row, "Long_2 (Pyr1)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr1_entry_price, "#.##") + " (" + str.tostring(pyr1_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long2, "#.##") + trail_info_2, bgcolor=color.new(color.green, 80))
            row := row + 1

        if not na(pyr2_entry_price)
            pyr2_lots = math.round(initial_position_size * math.pow(pyramid_size_ratio, 2))
            trail_info_3 = stop_loss_mode == "Tom Basso" and not na(highest_close_long3) ? " | Hi:" + str.tostring(highest_close_long3, "#") : ""

            table.cell(infoTable, 0, row, "Long_3 (Pyr2)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr2_entry_price, "#.##") + " (" + str.tostring(pyr2_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long3, "#.##") + trail_info_3, bgcolor=color.new(color.green, 80))
            row := row + 1

        if not na(pyr3_entry_price)
            pyr3_lots = math.round(initial_position_size * math.pow(pyramid_size_ratio, 3))
            trail_info_4 = stop_loss_mode == "Tom Basso" and not na(highest_close_long4) ? " | Hi:" + str.tostring(highest_close_long4, "#") : ""

            table.cell(infoTable, 0, row, "Long_4 (Pyr3)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr3_entry_price, "#.##") + " (" + str.tostring(pyr3_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long4, "#.##") + trail_info_4, bgcolor=color.new(color.green, 80))
            row := row + 1

        // v5 extension - Long_5 and Long_6
        if not na(pyr4_entry_price)
            pyr4_lots = math.round(initial_position_size * math.pow(pyramid_size_ratio, 4))
            trail_info_5 = stop_loss_mode == "Tom Basso" and not na(highest_close_long5) ? " | Hi:" + str.tostring(highest_close_long5, "#") : ""

            table.cell(infoTable, 0, row, "Long_5 (Pyr4)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr4_entry_price, "#.##") + " (" + str.tostring(pyr4_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long5, "#.##") + trail_info_5, bgcolor=color.new(color.green, 80))
            row := row + 1

        if not na(pyr5_entry_price)
            pyr5_lots = math.round(initial_position_size * math.pow(pyramid_size_ratio, 5))
            trail_info_6 = stop_loss_mode == "Tom Basso" and not na(highest_close_long6) ? " | Hi:" + str.tostring(highest_close_long6, "#") : ""

            table.cell(infoTable, 0, row, "Long_6 (Pyr5)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr5_entry_price, "#.##") + " (" + str.tostring(pyr5_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long6, "#.##") + trail_info_6, bgcolor=color.new(color.green, 80))
            row := row + 1

        // Tom Basso specific info row (when in Tom Basso mode)
        if stop_loss_mode == "Tom Basso"
            table.cell(infoTable, 0, row, "Basso ATR", bgcolor=color.new(color.maroon, 80))
            table.cell(infoTable, 1, row, str.tostring(atr_basso, "#.##"), bgcolor=color.new(color.maroon, 80))
            table.cell(infoTable, 2, row, "Init:" + str.tostring(basso_initial_atr_mult, "#.#") + "× Trail:" + str.tostring(basso_trailing_atr_mult, "#.#") + "×", bgcolor=color.new(color.maroon, 80))
            row := row + 1

        // Total position
        table.cell(infoTable, 0, row, "Total Position", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 1, row, str.tostring(strategy.position_size) + " Lots", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 2, row, "@ " + str.tostring(close, "#.##"), bgcolor=color.new(color.purple, 80))
        row := row + 1

        // Risk exposure
        risk_color = total_risk_exposure > equity_high * 0.05 ? color.red : color.orange
        table.cell(infoTable, 0, row, "Risk Exposure", bgcolor=color.new(risk_color, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(total_risk_exposure/100000, "#.##") + "L", bgcolor=color.new(risk_color, 80))
        table.cell(infoTable, 2, row, "If stopped out", bgcolor=color.new(risk_color, 80))
        row := row + 1

        // Open P&L
        table.cell(infoTable, 0, row, "Open P&L", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(unrealized_pnl/100000, "#.##") + "L", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
        table.cell(infoTable, 2, row, str.tostring(unrealized_pnl_r, "#.##") + "R", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
        row := row + 1

        // Margin info
        margin_color = margin_utilization_pct > 90 ? color.red : (margin_utilization_pct > 75 ? color.orange : color.green)
        table.cell(infoTable, 0, row, "Margin Used", bgcolor=color.new(margin_color, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(current_margin_used_display, "#.#") + "L", bgcolor=color.new(margin_color, 80))
        table.cell(infoTable, 2, row, str.tostring(margin_utilization_pct, "#.#") + "%", bgcolor=color.new(margin_color, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Margin Free", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(margin_remaining, "#.#") + "L", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 2, row, str.tostring(pyramid_count) + "/" + str.tostring(max_pyramids) + " Pyrs", bgcolor=color.new(color.blue, 80))
        row := row + 1

        // v5.2: PRICE-BASED PYRAMID GATE SECTION (Capital-Independent)
        gate_color = pyramid_gate_open ? color.green : color.red
        gate_status = pyramid_gate_open ? "✓ OPEN" : "✗ BLOCKED"
        gate_label = use_1r_gate ? "v5.2: Price > 1R" : "1R OFF (ATR only)"
        table.cell(infoTable, 0, row, "Pyramid Gate", bgcolor=color.new(gate_color, 80))
        table.cell(infoTable, 1, row, gate_status, bgcolor=color.new(gate_color, 80))
        table.cell(infoTable, 2, row, gate_label, bgcolor=color.new(gate_color, 80))
        row := row + 1

        // ATR Spacing from last pyramid (always show this)
        atr_spacing_ok = atr_moves_from_last >= atr_pyramid_threshold
        atr_spacing_color = atr_spacing_ok ? color.green : color.red
        atr_spacing_status = atr_spacing_ok ? "✓ OK" : "✗ WAIT"
        table.cell(infoTable, 0, row, "ATR Spacing", bgcolor=color.new(atr_spacing_color, 80))
        table.cell(infoTable, 1, row, str.tostring(atr_moves_from_last, "#.##") + " ATR", bgcolor=color.new(atr_spacing_color, 80))
        table.cell(infoTable, 2, row, atr_spacing_status + " (need " + str.tostring(atr_pyramid_threshold, "#.#") + ")", bgcolor=color.new(atr_spacing_color, 80))
        row := row + 1

        // v5.2: Show 1R calculation details (only if 1R gate is enabled)
        if use_1r_gate
            table.cell(infoTable, 0, row, "1R (Initial Risk)", bgcolor=color.new(color.orange, 80))
            table.cell(infoTable, 1, row, str.tostring(initial_risk_points, "#.##") + " pts", bgcolor=color.new(color.orange, 80))
            table.cell(infoTable, 2, row, "Entry - Stop", bgcolor=color.new(color.orange, 80))
            row := row + 1

            table.cell(infoTable, 0, row, "Price Move", bgcolor=color.new(color.blue, 80))
            table.cell(infoTable, 1, row, str.tostring(price_move_from_entry, "#.##") + " pts", bgcolor=color.new(color.blue, 80))
            table.cell(infoTable, 2, row, str.tostring(price_move_in_r, "#.##") + "R", bgcolor=color.new(color.blue, 80))
            row := row + 1

            // Show initial stop price (v5.2)
            table.cell(infoTable, 0, row, "Initial Stop", bgcolor=color.new(color.purple, 80))
            table.cell(infoTable, 1, row, str.tostring(initial_stop_price, "#.##"), bgcolor=color.new(color.purple, 80))
            table.cell(infoTable, 2, row, "At Entry", bgcolor=color.new(color.purple, 80))
            row := row + 1

        // LOT BREAKDOWN SECTION (when gate is evaluated)
        if enable_pyramiding and pyramid_count < max_pyramids
            table.cell(infoTable, 0, row, "Lot-A (Margin)", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 1, row, str.tostring(lot_a) + " lots", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 2, row, "From Margin", bgcolor=color.new(color.gray, 80))
            row := row + 1

            table.cell(infoTable, 0, row, "Lot-B (50%)", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 1, row, str.tostring(lot_b) + " lots", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 2, row, "Base × 50%", bgcolor=color.new(color.gray, 80))
            row := row + 1

            table.cell(infoTable, 0, row, "Lot-C (Risk)", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 1, row, str.tostring(lot_c) + " lots", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 2, row, "From Budget", bgcolor=color.new(color.gray, 80))
            row := row + 1

            min_lot = math.min(lot_a, math.min(lot_b, lot_c))
            limiter = min_lot == lot_a ? "Margin" : (min_lot == lot_b ? "50% Rule" : "Risk Budget")
            table.cell(infoTable, 0, row, "Next Pyramid", bgcolor=color.new(color.yellow, 80))
            table.cell(infoTable, 1, row, str.tostring(min_lot) + " lots", bgcolor=color.new(color.yellow, 80))
            table.cell(infoTable, 2, row, limiter, bgcolor=color.new(color.yellow, 80))
            row := row + 1

    // === CAPITAL INFO (when flat or debug mode) ===
    if not in_position or show_all_info
        // Calculate position sizing for display (uses realized equity)
        risk_amount = equity_high * (risk_percent / 100)
        risk_per_point = close - supertrend
        risk_per_lot = risk_per_point * lot_size
        risk_lots_preview = risk_per_lot > 0 ? (risk_amount / risk_per_lot) * er : 0
        risk_lots_preview_floored = math.floor(risk_lots_preview)
        margin_lots_preview = available_margin_lakhs > 0 ? math.floor(available_margin_lakhs / margin_per_lot) : 0
        final_lots_preview = math.max(0, math.min(risk_lots_preview_floored, margin_lots_preview))

        table.cell(infoTable, 0, row, "Current Equity", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(current_equity_lakhs, "#.#") + "L", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 2, row, "With Unrealized", bgcolor=color.new(color.blue, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Realized Equity", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(realized_equity_lakhs, "#.#") + "L", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 2, row, "Booked Only", bgcolor=color.new(color.purple, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Lot Size", bgcolor=color.new(color.orange, 80))
        table.cell(infoTable, 1, row, str.tostring(final_lots_preview) + " Lots", bgcolor=color.new(color.orange, 80))
        table.cell(infoTable, 2, row, "If entry now", bgcolor=color.new(color.orange, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Margin Avail", bgcolor=color.new(color.green, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(available_margin_lakhs, "#.#") + "L", bgcolor=color.new(color.green, 80))
        table.cell(infoTable, 2, row, use_leverage ? str.tostring(leverage_multiplier, "#.#") + "x Lev" : "Realized", bgcolor=color.new(color.green, 80))
        row := row + 1

        // Show SL Mode info when flat
        table.cell(infoTable, 0, row, "SL Mode", bgcolor=color.new(color.maroon, 80))
        table.cell(infoTable, 1, row, stop_loss_mode, bgcolor=color.new(color.maroon, 80))
        if stop_loss_mode == "Tom Basso"
            table.cell(infoTable, 2, row, "ATR(" + str.tostring(basso_atr_period) + ") = " + str.tostring(atr_basso, "#.##"), bgcolor=color.new(color.maroon, 80))
        else
            table.cell(infoTable, 2, row, "Active", bgcolor=color.new(color.maroon, 80))
        row := row + 1

        // v5.2 Version indicator when flat
        table.cell(infoTable, 0, row, "Version", bgcolor=color.new(color.gray, 80))
        table.cell(infoTable, 1, row, "v8.0 COPPER", bgcolor=color.new(color.gray, 80))
        table.cell(infoTable, 2, row, "19-Dec-2025", bgcolor=color.new(color.gray, 80))
        row := row + 1

// ========================================
// DEBUG PANEL - Shows condition states over time
// ========================================
// Plot all conditions (1 = true, 0 = false) in separate pane
// Display only when show_debug is enabled

plot(show_debug ? (rsi_condition ? 1 : 0) : na, "RSI>70", color=color.new(color.red, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (ema_condition ? 1 : 0) : na, "C>EMA", color=color.new(color.blue, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (dc_condition ? 1 : 0) : na, "C>DC", color=color.new(color.green, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (adx_condition ? 1 : 0) : na, "ADX<15", color=color.new(color.orange, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (er_condition ? 1 : 0) : na, "ER>0.8", color=color.new(color.purple, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (st_condition ? 1 : 0) : na, "C>ST", color=color.new(color.teal, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (not_doji ? 1 : 0) : na, "Not Doji", color=color.new(color.maroon, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (long_entry ? 7 : 0) : na, "ALL CONDITIONS", color=color.new(color.lime, 0), style=plot.style_columns, linewidth=3)

// ========================================
// EOD PRE-CLOSE MONITORING ALERT
// ========================================
// Sends EOD_MONITOR signal during the LAST 5 MINUTES before market close (23:25 onwards)
// Fires on EVERY TICK so Python gets real-time condition updates
// Python Portfolio Manager handles:
//   - Precise timing (executes at T-30s)
//   - Position sizing using REAL portfolio equity (shared across instruments)
//   - Margin validation across Bank Nifty + Gold Mini + Silver Mini + Copper positions
//
// MCX close time varies: 23:30 IST (US DST) or 23:55 IST (US Standard)
// Python EODScheduler dynamically determines actual close time
//
// ARCHITECTURE NOTE: TradingView is ONLY a signal generator.
// Position sizing MUST be calculated by Python using actual portfolio equity,
// NOT by Pine Script which doesn't know other instrument's positions.

// EOD Alert Window: Last 5 minutes - uses is_eod_alert_window defined above
if enable_eod_monitoring and is_eod_alert_window

    // Build EOD_MONITOR JSON - sends RAW DATA for Python to process
    // Python calculates position sizing using Tom Basso methodology with REAL equity

    json_conditions = '"conditions":{"rsi_condition":' + str.tostring(rsi_condition) + ',"ema_condition":' + str.tostring(ema_condition) + ',"dc_condition":' + str.tostring(dc_condition) + ',"adx_condition":' + str.tostring(adx_condition) + ',"er_condition":' + str.tostring(er_condition) + ',"st_condition":' + str.tostring(st_condition) + ',"not_doji":' + str.tostring(not_doji) + ',"long_entry":' + str.tostring(long_entry) + ',"long_exit":' + str.tostring(long_exit) + '}'

    json_indicators = '"indicators":{"rsi":' + str.tostring(rsi) + ',"ema":' + str.tostring(ema) + ',"dc_upper":' + str.tostring(dc_upper) + ',"adx":' + str.tostring(adx) + ',"er":' + str.tostring(er) + ',"supertrend":' + str.tostring(supertrend) + ',"atr":' + str.tostring(atr_pyramid) + '}'

    // Position status from Pine Script's view (for reference only)
    // Python uses its own position tracking with database state
    json_position = '"position_status":{"in_position":' + str.tostring(strategy.position_size > 0) + ',"pyramid_count":' + str.tostring(pyramid_count) + '}'

    // Generate timestamp
    timestamp_str = str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)

    // Complete EOD_MONITOR JSON
    eod_json = '{"type":"EOD_MONITOR","instrument":"COPPER","timestamp":"' + timestamp_str + '","price":' + str.tostring(close) + ',' + json_conditions + ',' + json_indicators + ',' + json_position + '}'

    // Fire on EVERY TICK during EOD window so Python gets latest values
    // Python ignores signals once execution has started
    alert(eod_json, alert.freq_all)
