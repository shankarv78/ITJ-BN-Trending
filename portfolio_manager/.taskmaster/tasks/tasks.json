{
  "master": {
    "tasks": [
      {
        "id": "40",
        "title": "Create Database Schema Migrations for Signal Audit and Order Execution",
        "description": "Implement SQL migrations to create signal_audit and order_execution_log tables with proper indexes, constraints, and retention policies",
        "details": "Create two migration files:\n\n1. migrations/010_signal_audit.sql:\n```sql\nCREATE TABLE signal_audit (\n    id BIGSERIAL PRIMARY KEY,\n    signal_log_id BIGINT REFERENCES signal_log(id),\n    signal_fingerprint VARCHAR(64) NOT NULL,\n    instrument VARCHAR(20) NOT NULL,\n    signal_type VARCHAR(20) NOT NULL,\n    position VARCHAR(20) NOT NULL,\n    signal_timestamp TIMESTAMP NOT NULL,\n    received_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    outcome VARCHAR(30) NOT NULL,\n    outcome_reason TEXT,\n    validation_result JSONB,\n    sizing_calculation JSONB,\n    risk_assessment JSONB,\n    order_execution JSONB,\n    processing_duration_ms INTEGER,\n    processed_by_instance VARCHAR(50),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    CONSTRAINT idx_signal_audit_fingerprint UNIQUE (signal_fingerprint)\n);\nCREATE INDEX idx_signal_audit_instrument_time ON signal_audit(instrument, signal_timestamp);\nCREATE INDEX idx_signal_audit_outcome ON signal_audit(outcome);\nCREATE INDEX idx_signal_audit_created ON signal_audit(created_at);\n```\n\n2. migrations/011_order_execution_log.sql:\n```sql\nCREATE TABLE order_execution_log (\n    id BIGSERIAL PRIMARY KEY,\n    signal_audit_id BIGINT REFERENCES signal_audit(id),\n    position_id VARCHAR(50),\n    order_id VARCHAR(100),\n    broker_order_id VARCHAR(100),\n    order_type VARCHAR(30) NOT NULL,\n    action VARCHAR(10) NOT NULL,\n    instrument VARCHAR(20) NOT NULL,\n    symbol VARCHAR(100) NOT NULL,\n    exchange VARCHAR(20) NOT NULL,\n    quantity INTEGER NOT NULL,\n    lots INTEGER NOT NULL,\n    signal_price DECIMAL(12,2),\n    limit_price DECIMAL(12,2),\n    fill_price DECIMAL(12,2),\n    slippage_pct DECIMAL(6,4),\n    order_status VARCHAR(20) NOT NULL,\n    status_message TEXT,\n    order_placed_at TIMESTAMP,\n    order_filled_at TIMESTAMP,\n    execution_duration_ms INTEGER,\n    parent_order_id BIGINT REFERENCES order_execution_log(id),\n    leg_number INTEGER,\n    raw_response JSONB,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\nCREATE INDEX idx_order_exec_signal ON order_execution_log(signal_audit_id);\nCREATE INDEX idx_order_exec_position ON order_execution_log(position_id);\nCREATE INDEX idx_order_exec_status ON order_execution_log(order_status);\nCREATE INDEX idx_order_exec_time ON order_execution_log(order_placed_at);\n```\n\n3. Add retention policy cleanup job (90 days retention)",
        "testStrategy": "1. Run migrations on test database and verify tables created successfully\n2. Verify all indexes are created with EXPLAIN ANALYZE queries\n3. Test foreign key constraints by attempting invalid inserts\n4. Verify JSONB columns accept valid JSON structures\n5. Test unique constraint on signal_fingerprint\n6. Verify self-referencing foreign key on order_execution_log.parent_order_id\n7. Test retention cleanup job with mock old data",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-06T16:30:10.102Z"
      },
      {
        "id": "41",
        "title": "Implement SignalAuditService Core Class",
        "description": "Create a service class to handle all signal audit trail operations including recording outcomes, validation results, sizing calculations, and order executions",
        "details": "Create core/signal_audit_service.py:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional, Dict, Any, List\nfrom datetime import datetime\nimport json\nfrom enum import Enum\n\nclass SignalOutcome(Enum):\n    PROCESSED = 'PROCESSED'\n    REJECTED_VALIDATION = 'REJECTED_VALIDATION'\n    REJECTED_RISK = 'REJECTED_RISK'\n    REJECTED_DUPLICATE = 'REJECTED_DUPLICATE'\n    REJECTED_MARKET_CLOSED = 'REJECTED_MARKET_CLOSED'\n    REJECTED_MANUAL_OVERRIDE = 'REJECTED_MANUAL_OVERRIDE'\n    FAILED_ORDER = 'FAILED_ORDER'\n    PARTIAL_FILL = 'PARTIAL_FILL'\n\n@dataclass\nclass SignalAuditRecord:\n    signal_fingerprint: str\n    instrument: str\n    signal_type: str\n    position: str\n    signal_timestamp: datetime\n    received_at: datetime\n    outcome: SignalOutcome\n    outcome_reason: Optional[str] = None\n    validation_result: Optional[Dict[str, Any]] = None\n    sizing_calculation: Optional[Dict[str, Any]] = None\n    risk_assessment: Optional[Dict[str, Any]] = None\n    order_execution: Optional[Dict[str, Any]] = None\n    processing_duration_ms: Optional[int] = None\n    processed_by_instance: Optional[str] = None\n    signal_log_id: Optional[int] = None\n\nclass SignalAuditService:\n    def __init__(self, db_manager):\n        self.db = db_manager\n    \n    def create_audit_record(self, record: SignalAuditRecord) -> int:\n        \"\"\"Insert signal audit record and return ID\"\"\"\n        query = \"\"\"\n            INSERT INTO signal_audit (\n                signal_log_id, signal_fingerprint, instrument, signal_type,\n                position, signal_timestamp, received_at, outcome, outcome_reason,\n                validation_result, sizing_calculation, risk_assessment,\n                order_execution, processing_duration_ms, processed_by_instance\n            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)\n            RETURNING id\n        \"\"\"\n        params = (\n            record.signal_log_id, record.signal_fingerprint, record.instrument,\n            record.signal_type, record.position, record.signal_timestamp,\n            record.received_at, record.outcome.value, record.outcome_reason,\n            json.dumps(record.validation_result) if record.validation_result else None,\n            json.dumps(record.sizing_calculation) if record.sizing_calculation else None,\n            json.dumps(record.risk_assessment) if record.risk_assessment else None,\n            json.dumps(record.order_execution) if record.order_execution else None,\n            record.processing_duration_ms, record.processed_by_instance\n        )\n        return self.db.execute_query(query, params, fetch_one=True)[0]\n    \n    def update_order_execution(self, signal_audit_id: int, order_execution: Dict[str, Any]):\n        \"\"\"Update order execution details for existing audit record\"\"\"\n        query = \"\"\"\n            UPDATE signal_audit \n            SET order_execution = %s, updated_at = CURRENT_TIMESTAMP\n            WHERE id = %s\n        \"\"\"\n        self.db.execute_query(query, (json.dumps(order_execution), signal_audit_id))\n    \n    def get_audit_by_fingerprint(self, fingerprint: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Retrieve full audit record by signal fingerprint\"\"\"\n        query = \"SELECT * FROM signal_audit WHERE signal_fingerprint = %s\"\n        return self.db.execute_query(query, (fingerprint,), fetch_one=True)\n    \n    def get_recent_signals(self, limit: int = 10) -> List[Dict[str, Any]]:\n        \"\"\"Get recent signal audit records\"\"\"\n        query = \"\"\"\n            SELECT * FROM signal_audit \n            ORDER BY created_at DESC \n            LIMIT %s\n        \"\"\"\n        return self.db.execute_query(query, (limit,), fetch_all=True)\n```",
        "testStrategy": "1. Unit test SignalAuditRecord dataclass creation with all fields\n2. Test create_audit_record with valid data and verify database insertion\n3. Test JSONB serialization for validation_result, sizing_calculation, risk_assessment\n4. Test update_order_execution updates existing record correctly\n5. Test get_audit_by_fingerprint retrieves correct record\n6. Test get_recent_signals returns records in correct order\n7. Test handling of None/optional fields\n8. Integration test with actual database connection",
        "priority": "high",
        "dependencies": [
          "40"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "42",
        "title": "Enhance Signal Validator to Return Structured Results",
        "description": "Modify the signal validator to return detailed validation results including rejection codes, reasons, and decision data for audit trail",
        "details": "Update core/signal_validator.py:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime\n\n@dataclass\nclass ValidationResult:\n    is_valid: bool\n    rejection_code: Optional[str] = None\n    rejection_reason: Optional[str] = None\n    decision_data: Optional[Dict[str, Any]] = None\n    checks_performed: Optional[Dict[str, bool]] = None\n\nclass SignalValidator:\n    def __init__(self, config):\n        self.config = config\n        self.max_signal_age_seconds = config.get('max_signal_age_seconds', 30)\n        self.max_divergence_pct = config.get('max_divergence_pct', 0.5)\n    \n    def validate_signal(self, signal: Dict[str, Any], current_price: float) -> ValidationResult:\n        \"\"\"Validate signal and return structured result\"\"\"\n        checks = {}\n        \n        # Check signal age\n        signal_timestamp = datetime.fromisoformat(signal['timestamp'])\n        received_at = datetime.now()\n        signal_age = (received_at - signal_timestamp).total_seconds()\n        checks['signal_age'] = signal_age <= self.max_signal_age_seconds\n        \n        if signal_age > self.max_signal_age_seconds:\n            return ValidationResult(\n                is_valid=False,\n                rejection_code='SIGNAL_STALE',\n                rejection_reason=f'Signal age {signal_age:.0f}s exceeds threshold {self.max_signal_age_seconds}s',\n                decision_data={\n                    'signal_timestamp': signal_timestamp.isoformat(),\n                    'received_at': received_at.isoformat(),\n                    'signal_age_seconds': signal_age,\n                    'threshold_seconds': self.max_signal_age_seconds,\n                    'severity': 'REJECTED'\n                },\n                checks_performed=checks\n            )\n        \n        # Check price divergence\n        signal_price = float(signal['price'])\n        divergence_pct = abs(current_price - signal_price) / signal_price * 100\n        checks['price_divergence'] = divergence_pct <= self.max_divergence_pct\n        \n        if divergence_pct > self.max_divergence_pct:\n            return ValidationResult(\n                is_valid=False,\n                rejection_code='PRICE_DIVERGENCE',\n                rejection_reason=f'Price divergence {divergence_pct:.2f}% exceeds threshold {self.max_divergence_pct}%',\n                decision_data={\n                    'signal_price': signal_price,\n                    'current_price': current_price,\n                    'divergence_pct': divergence_pct,\n                    'threshold_pct': self.max_divergence_pct,\n                    'severity': 'REJECTED'\n                },\n                checks_performed=checks\n            )\n        \n        # Check if market is open\n        is_market_open = self._is_market_open()\n        checks['market_open'] = is_market_open\n        \n        if not is_market_open:\n            return ValidationResult(\n                is_valid=False,\n                rejection_code='MARKET_CLOSED',\n                rejection_reason='Signal received outside market hours',\n                decision_data={\n                    'received_at': received_at.isoformat(),\n                    'market_status': 'CLOSED',\n                    'severity': 'REJECTED'\n                },\n                checks_performed=checks\n            )\n        \n        # All checks passed\n        return ValidationResult(\n            is_valid=True,\n            checks_performed=checks,\n            decision_data={'all_checks_passed': True}\n        )\n    \n    def _is_market_open(self) -> bool:\n        \"\"\"Check if market is currently open\"\"\"\n        # Implementation for market hours check\n        pass\n```",
        "testStrategy": "1. Test validate_signal returns ValidationResult with is_valid=True for valid signals\n2. Test SIGNAL_STALE rejection with signal older than threshold\n3. Test PRICE_DIVERGENCE rejection with divergent prices\n4. Test MARKET_CLOSED rejection outside market hours\n5. Verify decision_data contains all required fields for each rejection type\n6. Test checks_performed dictionary tracks all validation steps\n7. Test edge cases: exactly at threshold, future timestamps\n8. Verify rejection_reason is human-readable",
        "priority": "high",
        "dependencies": [
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "43",
        "title": "Enhance Position Sizer to Return Calculation Details",
        "description": "Modify position sizing logic to return detailed calculation breakdown including inputs, intermediate steps, constraints applied, and limiting factors",
        "details": "Update core/position_sizer.py:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Dict, Any, List, Optional\nfrom enum import Enum\n\nclass SizingMethod(Enum):\n    TOM_BASSO = 'TOM_BASSO'\n    FIXED_LOTS = 'FIXED_LOTS'\n    KELLY = 'KELLY'\n\nclass Limiter(Enum):\n    RISK = 'RISK'\n    VOLATILITY = 'VOLATILITY'\n    MARGIN = 'MARGIN'\n    MAX_LOTS = 'MAX_LOTS'\n\n@dataclass\nclass ConstraintApplication:\n    constraint: str\n    before: float\n    after: float\n    applied: bool\n    limit: Optional[float] = None\n\n@dataclass\nclass SizingCalculation:\n    sizing_method: SizingMethod\n    inputs: Dict[str, Any]\n    calculation: Dict[str, float]\n    constraints_applied: List[ConstraintApplication]\n    limiter: Limiter\n    final_lots: int\n\nclass PositionSizer:\n    def __init__(self, config):\n        self.config = config\n        self.max_lots_per_trade = config.get('max_lots_per_trade', 10)\n        self.min_lots = config.get('min_lots', 1)\n    \n    def calculate_position_size(self, \n                               equity_high: float,\n                               risk_percent: float,\n                               stop_distance: float,\n                               lot_size: int,\n                               point_value: float,\n                               efficiency_ratio: float,\n                               atr: float) -> SizingCalculation:\n        \"\"\"Calculate position size using Tom Basso method with full audit trail\"\"\"\n        \n        # Store inputs\n        inputs = {\n            'equity_high': equity_high,\n            'risk_percent': risk_percent,\n            'stop_distance': stop_distance,\n            'lot_size': lot_size,\n            'point_value': point_value,\n            'efficiency_ratio': efficiency_ratio,\n            'atr': atr\n        }\n        \n        # Calculate risk amount\n        risk_amount = equity_high * (risk_percent / 100)\n        \n        # Calculate raw lots based on risk\n        risk_per_lot = stop_distance * lot_size * point_value\n        raw_lots = risk_amount / risk_per_lot\n        \n        # Apply efficiency ratio adjustment\n        er_adjusted_lots = raw_lots * efficiency_ratio\n        \n        # Track constraints\n        constraints = []\n        current_lots = er_adjusted_lots\n        limiter = Limiter.RISK\n        \n        # Apply floor constraint\n        floored_lots = int(current_lots)\n        constraints.append(ConstraintApplication(\n            constraint='FLOOR',\n            before=current_lots,\n            after=floored_lots,\n            applied=True\n        ))\n        current_lots = floored_lots\n        \n        # Apply max lots constraint\n        if current_lots > self.max_lots_per_trade:\n            constraints.append(ConstraintApplication(\n                constraint='MAX_LOTS_PER_TRADE',\n                before=current_lots,\n                after=self.max_lots_per_trade,\n                applied=True,\n                limit=self.max_lots_per_trade\n            ))\n            current_lots = self.max_lots_per_trade\n            limiter = Limiter.MAX_LOTS\n        else:\n            constraints.append(ConstraintApplication(\n                constraint='MAX_LOTS_PER_TRADE',\n                before=current_lots,\n                after=current_lots,\n                applied=False,\n                limit=self.max_lots_per_trade\n            ))\n        \n        # Apply min lots constraint\n        if current_lots < self.min_lots:\n            current_lots = self.min_lots\n        \n        calculation = {\n            'risk_amount': risk_amount,\n            'risk_per_lot': risk_per_lot,\n            'raw_lots': raw_lots,\n            'er_adjusted_lots': er_adjusted_lots,\n            'final_lots': current_lots\n        }\n        \n        return SizingCalculation(\n            sizing_method=SizingMethod.TOM_BASSO,\n            inputs=inputs,\n            calculation=calculation,\n            constraints_applied=constraints,\n            limiter=limiter,\n            final_lots=int(current_lots)\n        )\n```",
        "testStrategy": "1. Test calculate_position_size returns SizingCalculation with all fields populated\n2. Test raw lots calculation matches expected formula\n3. Test efficiency ratio adjustment applied correctly\n4. Test floor constraint records before/after values\n5. Test max_lots_per_trade constraint triggers when exceeded\n6. Test limiter correctly identifies RISK vs MAX_LOTS limitation\n7. Test min_lots constraint applied when calculated lots too small\n8. Verify inputs dictionary captures all parameters\n9. Test edge cases: zero stop distance, very high equity\n10. Verify calculation dictionary has all intermediate values",
        "priority": "high",
        "dependencies": [
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "44",
        "title": "Create Order Execution Logger",
        "description": "Implement service to log order execution details including multi-leg orders, fill prices, slippage, and broker responses to order_execution_log table",
        "details": "Create core/order_execution_logger.py:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional, Dict, Any, List\nfrom datetime import datetime\nimport json\n\n@dataclass\nclass OrderLeg:\n    leg_number: int\n    leg_name: str  # CE_BUY, PE_SELL, etc.\n    symbol: str\n    quantity: int\n    order_status: str\n    fill_price: Optional[float] = None\n    fill_time: Optional[datetime] = None\n\n@dataclass\nclass OrderExecutionRecord:\n    signal_audit_id: int\n    position_id: Optional[str]\n    order_id: str\n    broker_order_id: Optional[str]\n    order_type: str  # SYNTHETIC_FUTURES, DIRECT_FUTURES, OPTION\n    action: str  # BUY, SELL\n    instrument: str\n    symbol: str\n    exchange: str\n    quantity: int\n    lots: int\n    signal_price: Optional[float]\n    limit_price: Optional[float]\n    fill_price: Optional[float]\n    slippage_pct: Optional[float]\n    order_status: str  # PENDING, COMPLETE, REJECTED, CANCELLED, PARTIAL\n    status_message: Optional[str]\n    order_placed_at: Optional[datetime]\n    order_filled_at: Optional[datetime]\n    execution_duration_ms: Optional[int]\n    parent_order_id: Optional[int]\n    leg_number: Optional[int]\n    raw_response: Optional[Dict[str, Any]]\n\nclass OrderExecutionLogger:\n    def __init__(self, db_manager):\n        self.db = db_manager\n    \n    def log_order(self, record: OrderExecutionRecord) -> int:\n        \"\"\"Log order execution and return ID\"\"\"\n        query = \"\"\"\n            INSERT INTO order_execution_log (\n                signal_audit_id, position_id, order_id, broker_order_id,\n                order_type, action, instrument, symbol, exchange,\n                quantity, lots, signal_price, limit_price, fill_price,\n                slippage_pct, order_status, status_message,\n                order_placed_at, order_filled_at, execution_duration_ms,\n                parent_order_id, leg_number, raw_response\n            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)\n            RETURNING id\n        \"\"\"\n        params = (\n            record.signal_audit_id, record.position_id, record.order_id,\n            record.broker_order_id, record.order_type, record.action,\n            record.instrument, record.symbol, record.exchange,\n            record.quantity, record.lots, record.signal_price,\n            record.limit_price, record.fill_price, record.slippage_pct,\n            record.order_status, record.status_message,\n            record.order_placed_at, record.order_filled_at,\n            record.execution_duration_ms, record.parent_order_id,\n            record.leg_number, json.dumps(record.raw_response) if record.raw_response else None\n        )\n        return self.db.execute_query(query, params, fetch_one=True)[0]\n    \n    def log_multi_leg_order(self, signal_audit_id: int, order_type: str,\n                           legs: List[OrderLeg], signal_price: float,\n                           execution_status: str) -> Dict[str, Any]:\n        \"\"\"Log multi-leg order (e.g., synthetic futures) with parent-child relationship\"\"\"\n        # Create parent order record\n        parent_record = OrderExecutionRecord(\n            signal_audit_id=signal_audit_id,\n            position_id=None,\n            order_id=f\"PARENT_{datetime.now().strftime('%Y%m%d_%H%M%S')}\",\n            broker_order_id=None,\n            order_type=order_type,\n            action='MULTI_LEG',\n            instrument='',\n            symbol='',\n            exchange='',\n            quantity=sum(leg.quantity for leg in legs),\n            lots=0,\n            signal_price=signal_price,\n            limit_price=None,\n            fill_price=None,\n            slippage_pct=None,\n            order_status=execution_status,\n            status_message=f'{len(legs)} legs',\n            order_placed_at=datetime.now(),\n            order_filled_at=None,\n            execution_duration_ms=None,\n            parent_order_id=None,\n            leg_number=None,\n            raw_response=None\n        )\n        parent_id = self.log_order(parent_record)\n        \n        # Log each leg\n        leg_ids = []\n        for leg in legs:\n            leg_record = OrderExecutionRecord(\n                signal_audit_id=signal_audit_id,\n                position_id=None,\n                order_id=f\"LEG_{leg.leg_number}_{datetime.now().strftime('%Y%m%d_%H%M%S')}\",\n                broker_order_id=None,\n                order_type=order_type,\n                action=leg.leg_name,\n                instrument='',\n                symbol=leg.symbol,\n                exchange='NFO',\n                quantity=leg.quantity,\n                lots=0,\n                signal_price=None,\n                limit_price=None,\n                fill_price=leg.fill_price,\n                slippage_pct=None,\n                order_status=leg.order_status,\n                status_message=None,\n                order_placed_at=datetime.now(),\n                order_filled_at=leg.fill_time,\n                execution_duration_ms=None,\n                parent_order_id=parent_id,\n                leg_number=leg.leg_number,\n                raw_response=None\n            )\n            leg_ids.append(self.log_order(leg_record))\n        \n        # Calculate synthetic price and slippage\n        if all(leg.fill_price for leg in legs):\n            synthetic_price = self._calculate_synthetic_price(legs)\n            slippage_pct = abs(synthetic_price - signal_price) / signal_price * 100\n            \n            # Update parent with calculated values\n            self._update_order_slippage(parent_id, synthetic_price, slippage_pct)\n        \n        return {\n            'parent_id': parent_id,\n            'leg_ids': leg_ids,\n            'execution_status': execution_status\n        }\n    \n    def _calculate_synthetic_price(self, legs: List[OrderLeg]) -> float:\n        \"\"\"Calculate synthetic futures price from option legs\"\"\"\n        # Simplified: CE_price - PE_price + strike\n        # Actual implementation depends on leg structure\n        return 0.0\n    \n    def _update_order_slippage(self, order_id: int, fill_price: float, slippage_pct: float):\n        \"\"\"Update order with fill price and slippage\"\"\"\n        query = \"\"\"\n            UPDATE order_execution_log\n            SET fill_price = %s, slippage_pct = %s, updated_at = CURRENT_TIMESTAMP\n            WHERE id = %s\n        \"\"\"\n        self.db.execute_query(query, (fill_price, slippage_pct, order_id))\n    \n    def get_orders_by_signal(self, signal_audit_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all orders for a signal\"\"\"\n        query = \"\"\"\n            SELECT * FROM order_execution_log\n            WHERE signal_audit_id = %s\n            ORDER BY leg_number NULLS FIRST, created_at\n        \"\"\"\n        return self.db.execute_query(query, (signal_audit_id,), fetch_all=True)\n```",
        "testStrategy": "1. Test log_order inserts single order record successfully\n2. Test log_multi_leg_order creates parent and child records with correct relationships\n3. Test parent_order_id foreign key links legs to parent\n4. Test slippage calculation for synthetic futures\n5. Test get_orders_by_signal retrieves all related orders\n6. Test raw_response JSONB serialization\n7. Test execution_duration_ms calculation\n8. Test order status transitions (PENDING -> COMPLETE)\n9. Verify leg_number ordering in multi-leg queries\n10. Integration test with actual broker response data",
        "priority": "high",
        "dependencies": [
          "40",
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "45",
        "title": "Integrate Audit Trail into LiveTradingEngine",
        "description": "Modify the LiveTradingEngine to capture and persist audit trail at each decision point: validation, sizing, risk checks, and order execution",
        "details": "Update live/engine.py:\n\n```python\nimport time\nfrom datetime import datetime\nfrom core.signal_audit_service import SignalAuditService, SignalAuditRecord, SignalOutcome\nfrom core.order_execution_logger import OrderExecutionLogger\n\nclass LiveTradingEngine:\n    def __init__(self, config, db_manager, signal_validator, position_sizer, order_executor):\n        self.config = config\n        self.db = db_manager\n        self.validator = signal_validator\n        self.sizer = position_sizer\n        self.executor = order_executor\n        self.audit_service = SignalAuditService(db_manager)\n        self.order_logger = OrderExecutionLogger(db_manager)\n        self.instance_id = config.get('instance_id', 'PM_MAIN')\n    \n    def process_signal(self, signal: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process signal with full audit trail\"\"\"\n        start_time = time.time()\n        received_at = datetime.now()\n        \n        # Generate fingerprint\n        fingerprint = self._generate_fingerprint(signal)\n        \n        # Check for duplicate\n        if self._is_duplicate(fingerprint):\n            audit_record = SignalAuditRecord(\n                signal_fingerprint=fingerprint,\n                instrument=signal['instrument'],\n                signal_type=signal['type'],\n                position=signal['position'],\n                signal_timestamp=datetime.fromisoformat(signal['timestamp']),\n                received_at=received_at,\n                outcome=SignalOutcome.REJECTED_DUPLICATE,\n                outcome_reason='Signal already processed',\n                processed_by_instance=self.instance_id\n            )\n            self.audit_service.create_audit_record(audit_record)\n            return {'status': 'rejected', 'reason': 'duplicate'}\n        \n        # Validate signal\n        validation_result = self.validator.validate_signal(signal, self._get_current_price(signal['instrument']))\n        \n        if not validation_result.is_valid:\n            processing_duration = int((time.time() - start_time) * 1000)\n            audit_record = SignalAuditRecord(\n                signal_fingerprint=fingerprint,\n                instrument=signal['instrument'],\n                signal_type=signal['type'],\n                position=signal['position'],\n                signal_timestamp=datetime.fromisoformat(signal['timestamp']),\n                received_at=received_at,\n                outcome=self._map_validation_to_outcome(validation_result.rejection_code),\n                outcome_reason=validation_result.rejection_reason,\n                validation_result={\n                    'rejection_code': validation_result.rejection_code,\n                    'rejection_reason': validation_result.rejection_reason,\n                    'decision_data': validation_result.decision_data\n                },\n                processing_duration_ms=processing_duration,\n                processed_by_instance=self.instance_id\n            )\n            self.audit_service.create_audit_record(audit_record)\n            return {'status': 'rejected', 'reason': validation_result.rejection_code}\n        \n        # Calculate position size\n        sizing_calc = self.sizer.calculate_position_size(\n            equity_high=self._get_equity_high(),\n            risk_percent=self.config['risk_percent'],\n            stop_distance=signal['stop_distance'],\n            lot_size=self._get_lot_size(signal['instrument']),\n            point_value=self._get_point_value(signal['instrument']),\n            efficiency_ratio=signal.get('efficiency_ratio', 1.0),\n            atr=signal.get('atr', 0)\n        )\n        \n        # Perform risk checks\n        risk_check = self._perform_risk_checks(sizing_calc.final_lots, signal['instrument'])\n        \n        if not risk_check['passed']:\n            processing_duration = int((time.time() - start_time) * 1000)\n            audit_record = SignalAuditRecord(\n                signal_fingerprint=fingerprint,\n                instrument=signal['instrument'],\n                signal_type=signal['type'],\n                position=signal['position'],\n                signal_timestamp=datetime.fromisoformat(signal['timestamp']),\n                received_at=received_at,\n                outcome=SignalOutcome.REJECTED_RISK,\n                outcome_reason=risk_check['reason'],\n                validation_result={'is_valid': True, 'checks_passed': validation_result.checks_performed},\n                sizing_calculation=self._serialize_sizing_calc(sizing_calc),\n                risk_assessment=risk_check,\n                processing_duration_ms=processing_duration,\n                processed_by_instance=self.instance_id\n            )\n            self.audit_service.create_audit_record(audit_record)\n            return {'status': 'rejected', 'reason': 'risk_check_failed'}\n        \n        # Execute order\n        order_result = self.executor.place_order(\n            instrument=signal['instrument'],\n            action=signal['position'],\n            lots=sizing_calc.final_lots,\n            order_type=signal.get('order_type', 'SYNTHETIC_FUTURES')\n        )\n        \n        processing_duration = int((time.time() - start_time) * 1000)\n        \n        # Create audit record\n        outcome = SignalOutcome.PROCESSED if order_result['status'] == 'SUCCESS' else SignalOutcome.FAILED_ORDER\n        audit_record = SignalAuditRecord(\n            signal_fingerprint=fingerprint,\n            instrument=signal['instrument'],\n            signal_type=signal['type'],\n            position=signal['position'],\n            signal_timestamp=datetime.fromisoformat(signal['timestamp']),\n            received_at=received_at,\n            outcome=outcome,\n            outcome_reason=order_result.get('message'),\n            validation_result={'is_valid': True, 'checks_passed': validation_result.checks_performed},\n            sizing_calculation=self._serialize_sizing_calc(sizing_calc),\n            risk_assessment=risk_check,\n            processing_duration_ms=processing_duration,\n            processed_by_instance=self.instance_id\n        )\n        audit_id = self.audit_service.create_audit_record(audit_record)\n        \n        # Log order execution\n        if order_result.get('legs'):\n            self.order_logger.log_multi_leg_order(\n                signal_audit_id=audit_id,\n                order_type=signal.get('order_type', 'SYNTHETIC_FUTURES'),\n                legs=order_result['legs'],\n                signal_price=float(signal['price']),\n                execution_status=order_result['status']\n            )\n        \n        return {'status': 'processed', 'audit_id': audit_id, 'order_result': order_result}\n    \n    def _serialize_sizing_calc(self, sizing_calc) -> Dict[str, Any]:\n        \"\"\"Convert SizingCalculation to dict for JSON storage\"\"\"\n        return {\n            'sizing_method': sizing_calc.sizing_method.value,\n            'inputs': sizing_calc.inputs,\n            'calculation': sizing_calc.calculation,\n            'constraints_applied': [\n                {'constraint': c.constraint, 'before': c.before, 'after': c.after, 'applied': c.applied, 'limit': c.limit}\n                for c in sizing_calc.constraints_applied\n            ],\n            'limiter': sizing_calc.limiter.value\n        }\n    \n    def _map_validation_to_outcome(self, rejection_code: str) -> SignalOutcome:\n        \"\"\"Map validation rejection code to signal outcome\"\"\"\n        mapping = {\n            'SIGNAL_STALE': SignalOutcome.REJECTED_VALIDATION,\n            'PRICE_DIVERGENCE': SignalOutcome.REJECTED_VALIDATION,\n            'MARKET_CLOSED': SignalOutcome.REJECTED_MARKET_CLOSED\n        }\n        return mapping.get(rejection_code, SignalOutcome.REJECTED_VALIDATION)\n```",
        "testStrategy": "1. Test process_signal creates audit record for duplicate signals\n2. Test validation failure creates audit with validation_result populated\n3. Test risk check failure creates audit with risk_assessment populated\n4. Test successful signal creates audit with all fields populated\n5. Test order execution failure creates FAILED_ORDER outcome\n6. Test processing_duration_ms calculated correctly\n7. Test multi-leg order logging integration\n8. Test _serialize_sizing_calc converts dataclass to dict correctly\n9. Integration test: end-to-end signal processing with database verification\n10. Test concurrent signal processing doesn't create duplicate audits",
        "priority": "high",
        "dependencies": [
          "41",
          "42",
          "43",
          "44"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "46",
        "title": "Implement Telegram Bot Core with Command Handlers",
        "description": "Create Telegram bot service with python-telegram-bot library implementing all query commands: /status, /positions, /signals, /pnl, /equity, /risk, /orders, /ping, /help",
        "details": "Create core/telegram_bot.py:\n\n```python\nimport logging\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes\nfrom datetime import datetime\nimport json\nfrom typing import Dict, Any\n\nlogger = logging.getLogger(__name__)\n\nclass PMTelegramBot:\n    def __init__(self, config, db_manager, audit_service, order_logger):\n        self.config = config\n        self.db = db_manager\n        self.audit_service = audit_service\n        self.order_logger = order_logger\n        self.bot_token = config['telegram']['bot_token']\n        self.authorized_chat_id = config['telegram']['chat_id']\n        self.enabled = config['telegram'].get('enabled', True)\n        self.application = None\n    \n    async def start(self):\n        \"\"\"Initialize and start the bot\"\"\"\n        if not self.enabled:\n            logger.info(\"Telegram bot disabled in config\")\n            return\n        \n        self.application = Application.builder().token(self.bot_token).build()\n        \n        # Register command handlers\n        self.application.add_handler(CommandHandler(\"start\", self.cmd_start))\n        self.application.add_handler(CommandHandler(\"status\", self.cmd_status))\n        self.application.add_handler(CommandHandler(\"positions\", self.cmd_positions))\n        self.application.add_handler(CommandHandler(\"signals\", self.cmd_signals))\n        self.application.add_handler(CommandHandler(\"signal\", self.cmd_signal_detail))\n        self.application.add_handler(CommandHandler(\"pnl\", self.cmd_pnl))\n        self.application.add_handler(CommandHandler(\"equity\", self.cmd_equity))\n        self.application.add_handler(CommandHandler(\"risk\", self.cmd_risk))\n        self.application.add_handler(CommandHandler(\"orders\", self.cmd_orders))\n        self.application.add_handler(CommandHandler(\"ping\", self.cmd_ping))\n        self.application.add_handler(CommandHandler(\"help\", self.cmd_help))\n        \n        # Callback query handler for inline buttons\n        self.application.add_handler(CallbackQueryHandler(self.button_callback))\n        \n        # Error handler\n        self.application.add_error_handler(self.error_handler)\n        \n        # Start polling\n        await self.application.initialize()\n        await self.application.start()\n        await self.application.updater.start_polling()\n        logger.info(\"Telegram bot started\")\n    \n    def _check_authorization(self, update: Update) -> bool:\n        \"\"\"Check if user is authorized\"\"\"\n        return str(update.effective_chat.id) == str(self.authorized_chat_id)\n    \n    async def cmd_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /start command\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        await update.message.reply_text(\n            \"ğŸ¤– *PM Telegram Bot*\\n\\n\"\n            \"Portfolio Manager monitoring and control.\\n\\n\"\n            \"Use /help to see available commands.\",\n            parse_mode='Markdown'\n        )\n    \n    async def cmd_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /status command\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        # Query system status\n        status_data = self._get_system_status()\n        \n        message = f\"\"\"ğŸ¤– *PM Status*\n\n*Status:* {'ğŸŸ¢ Running' if status_data['running'] else 'ğŸ”´ Stopped'}\n*Uptime:* {status_data['uptime']}\n*Mode:* {status_data['mode']}\n\n*Positions:*\nâ”œâ”€ Open: {status_data['positions']['open']}\n{self._format_position_list(status_data['positions']['list'])}\n\n*Today:*\nâ”œâ”€ Signals: {status_data['today']['signals']} ({status_data['today']['processed']} processed, {status_data['today']['rejected']} rejected)\nâ”œâ”€ Orders: {status_data['today']['orders']} ({status_data['today']['filled']} filled)\nâ””â”€ P&L: â‚¹{status_data['today']['pnl']:,.0f}\n\n*System:*\nâ”œâ”€ DB: {'Connected âœ…' if status_data['system']['db_connected'] else 'Disconnected âŒ'}\nâ”œâ”€ Broker: {'Connected âœ…' if status_data['system']['broker_connected'] else 'Disconnected âŒ'}\nâ””â”€ Last Heartbeat: {status_data['system']['last_heartbeat']}\n\"\"\"\n        await update.message.reply_text(message, parse_mode='Markdown')\n    \n    async def cmd_signals(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /signals command - show recent signals\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        signals = self.audit_service.get_recent_signals(limit=10)\n        \n        if not signals:\n            await update.message.reply_text(\"No recent signals found.\")\n            return\n        \n        message = \"ğŸ“Š *Recent Signals (Last 10)*\\n\\n\"\n        for sig in signals:\n            outcome_emoji = 'âœ…' if sig['outcome'] == 'PROCESSED' else 'â›”'\n            message += f\"{outcome_emoji} {sig['instrument']} {sig['signal_type']}\\n\"\n            message += f\"   {sig['signal_timestamp'].strftime('%H:%M:%S')} - {sig['outcome']}\\n\"\n            message += f\"   `/signal {sig['signal_fingerprint'][:8]}`\\n\\n\"\n        \n        await update.message.reply_text(message, parse_mode='Markdown')\n    \n    async def cmd_signal_detail(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /signal <fingerprint> command\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        if not context.args:\n            await update.message.reply_text(\"Usage: /signal <fingerprint>\")\n            return\n        \n        fingerprint_prefix = context.args[0]\n        # Query signal by fingerprint prefix\n        signal = self._get_signal_by_prefix(fingerprint_prefix)\n        \n        if not signal:\n            await update.message.reply_text(\"Signal not found.\")\n            return\n        \n        message = self._format_signal_detail(signal)\n        await update.message.reply_text(message, parse_mode='Markdown')\n    \n    async def cmd_pnl(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /pnl command\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        pnl_data = self._get_pnl_summary()\n        \n        message = f\"\"\"ğŸ’° *P&L Summary*\n\n*Today:*\nâ”œâ”€ Realized: â‚¹{pnl_data['today']['realized']:,.2f}\nâ”œâ”€ Unrealized: â‚¹{pnl_data['today']['unrealized']:,.2f}\nâ””â”€ Total: â‚¹{pnl_data['today']['total']:,.2f}\n\n*This Week:*\nâ””â”€ Total: â‚¹{pnl_data['week']['total']:,.2f}\n\n*This Month:*\nâ””â”€ Total: â‚¹{pnl_data['month']['total']:,.2f}\n\"\"\"\n        await update.message.reply_text(message, parse_mode='Markdown')\n    \n    async def cmd_positions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /positions command\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        positions = self._get_open_positions()\n        \n        if not positions:\n            await update.message.reply_text(\"No open positions.\")\n            return\n        \n        message = \"ğŸ“ˆ *Open Positions*\\n\\n\"\n        for pos in positions:\n            pnl_emoji = 'ğŸŸ¢' if pos['pnl'] >= 0 else 'ğŸ”´'\n            message += f\"{pnl_emoji} *{pos['instrument']}*\\n\"\n            message += f\"   Entry: â‚¹{pos['entry_price']:,.2f} | Lots: {pos['lots']}\\n\"\n            message += f\"   Current: â‚¹{pos['current_price']:,.2f}\\n\"\n            message += f\"   P&L: â‚¹{pos['pnl']:,.2f}\\n\\n\"\n        \n        await update.message.reply_text(message, parse_mode='Markdown')\n    \n    async def cmd_equity(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /equity command\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        equity_data = self._get_equity_info()\n        \n        message = f\"\"\"ğŸ’¼ *Portfolio Equity*\n\n*Closed Equity:* â‚¹{equity_data['closed_equity']:,.2f}\n*Open P&L:* â‚¹{equity_data['open_pnl']:,.2f}\n*Total Equity:* â‚¹{equity_data['total_equity']:,.2f}\n\n*Margin:*\nâ”œâ”€ Used: â‚¹{equity_data['margin']['used']:,.2f}\nâ”œâ”€ Available: â‚¹{equity_data['margin']['available']:,.2f}\nâ””â”€ Utilization: {equity_data['margin']['utilization_pct']:.1f}%\n\"\"\"\n        await update.message.reply_text(message, parse_mode='Markdown')\n    \n    async def cmd_risk(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /risk command\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        risk_data = self._get_risk_exposure()\n        \n        message = f\"\"\"âš ï¸ *Risk Exposure*\n\n*Current Risk:*\nâ”œâ”€ Risk %: {risk_data['risk_pct']:.2f}%\nâ”œâ”€ Risk Amount: â‚¹{risk_data['risk_amount']:,.2f}\nâ””â”€ Max Risk: â‚¹{risk_data['max_risk']:,.2f}\n\n*Volatility:*\nâ”œâ”€ Portfolio Vol: {risk_data['volatility_pct']:.2f}%\nâ””â”€ Vol Limit: {risk_data['vol_limit_pct']:.2f}%\n\n*Position Limits:*\nâ”œâ”€ Open Positions: {risk_data['positions']['open']}\nâ””â”€ Max Positions: {risk_data['positions']['max']}\n\"\"\"\n        await update.message.reply_text(message, parse_mode='Markdown')\n    \n    async def cmd_orders(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /orders command\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        orders = self._get_todays_orders()\n        \n        if not orders:\n            await update.message.reply_text(\"No orders today.\")\n            return\n        \n        message = \"ğŸ“¤ *Today's Orders*\\n\\n\"\n        for order in orders:\n            status_emoji = 'âœ…' if order['status'] == 'COMPLETE' else 'â³' if order['status'] == 'PENDING' else 'âŒ'\n            message += f\"{status_emoji} {order['action']} {order['lots']} lots {order['instrument']}\\n\"\n            message += f\"   {order['order_type']} @ â‚¹{order['fill_price']:,.2f}\\n\"\n            message += f\"   {order['placed_at'].strftime('%H:%M:%S')} - {order['status']}\\n\\n\"\n        \n        await update.message.reply_text(message, parse_mode='Markdown')\n    \n    async def cmd_ping(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /ping command\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        start_time = datetime.now()\n        await update.message.reply_text(\"ğŸ“ Pong!\")\n        latency = (datetime.now() - start_time).total_seconds() * 1000\n        await update.message.reply_text(f\"Latency: {latency:.0f}ms\")\n    \n    async def cmd_help(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /help command\"\"\"\n        if not self._check_authorization(update):\n            await update.message.reply_text(\"â›” Unauthorized\")\n            return\n        \n        message = \"\"\"ğŸ“š *Available Commands*\n\n/status - PM system status\n/positions - Current open positions\n/signals - Recent signals (last 10)\n/signal <id> - Detailed signal info\n/pnl - Today's P&L summary\n/equity - Portfolio equity\n/risk - Current risk exposure\n/orders - Today's orders\n/ping - Heartbeat check\n/help - This message\n\"\"\"\n        await update.message.reply_text(message, parse_mode='Markdown')\n    \n    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle inline button callbacks\"\"\"\n        query = update.callback_query\n        await query.answer()\n        # Handle button actions if needed\n    \n    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle errors\"\"\"\n        logger.error(f\"Telegram bot error: {context.error}\")\n    \n    # Helper methods to query data\n    def _get_system_status(self) -> Dict[str, Any]:\n        # Implementation to query system status\n        pass\n    \n    def _format_position_list(self, positions: list) -> str:\n        # Format position list for display\n        pass\n    \n    def _get_signal_by_prefix(self, prefix: str) -> Dict[str, Any]:\n        # Query signal by fingerprint prefix\n        pass\n    \n    def _format_signal_detail(self, signal: Dict[str, Any]) -> str:\n        # Format detailed signal information\n        pass\n    \n    def _get_pnl_summary(self) -> Dict[str, Any]:\n        # Query P&L data\n        pass\n    \n    def _get_open_positions(self) -> list:\n        # Query open positions\n        pass\n    \n    def _get_equity_info(self) -> Dict[str, Any]:\n        # Query equity information\n        pass\n    \n    def _get_risk_exposure(self) -> Dict[str, Any]:\n        # Query risk metrics\n        pass\n    \n    def _get_todays_orders(self) -> list:\n        # Query today's orders\n        pass\n```",
        "testStrategy": "1. Test bot initialization with valid token and chat ID\n2. Test authorization check rejects unauthorized users\n3. Test each command handler with mock data\n4. Test /status returns formatted system status\n5. Test /signals lists recent signals with correct formatting\n6. Test /signal <fingerprint> retrieves and formats signal detail\n7. Test /pnl calculates and displays P&L correctly\n8. Test /positions shows open positions with current P&L\n9. Test /ping responds with latency measurement\n10. Test error_handler logs errors correctly\n11. Integration test: send commands via Telegram API and verify responses\n12. Test markdown formatting renders correctly in Telegram",
        "priority": "high",
        "dependencies": [
          "45"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "47",
        "title": "Implement Telegram Alert Publisher",
        "description": "Create alert publishing service to send proactive notifications for signal events, order executions, stops hit, and system errors",
        "details": "Create core/telegram_alerts.py:\n\n```python\nimport logging\nfrom telegram import Bot\nfrom typing import Dict, Any, Optional\nfrom datetime import datetime\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\nclass TelegramAlertPublisher:\n    def __init__(self, config):\n        self.config = config\n        self.bot_token = config['telegram']['bot_token']\n        self.chat_id = config['telegram']['chat_id']\n        self.enabled = config['telegram'].get('enabled', True)\n        self.alert_config = config['telegram'].get('alerts', {})\n        self.bot = Bot(token=self.bot_token) if self.enabled else None\n        self.message_queue = asyncio.Queue()\n    \n    async def send_alert(self, alert_type: str, data: Dict[str, Any]):\n        \"\"\"Send alert if enabled for this type\"\"\"\n        if not self.enabled or not self.alert_config.get(alert_type, True):\n            return\n        \n        message = self._format_alert(alert_type, data)\n        if message:\n            await self._send_message(message)\n    \n    async def _send_message(self, message: str):\n        \"\"\"Send message to Telegram with rate limiting\"\"\"\n        try:\n            await self.bot.send_message(\n                chat_id=self.chat_id,\n                text=message,\n                parse_mode='Markdown'\n            )\n        except Exception as e:\n            logger.error(f\"Failed to send Telegram alert: {e}\")\n    \n    def _format_alert(self, alert_type: str, data: Dict[str, Any]) -> Optional[str]:\n        \"\"\"Format alert message based on type\"\"\"\n        formatters = {\n            'signal_received': self._format_signal_received,\n            'signal_rejected': self._format_signal_rejected,\n            'order_placed': self._format_order_placed,\n            'order_filled': self._format_order_filled,\n            'order_failed': self._format_order_failed,\n            'stop_hit': self._format_stop_hit,\n            'system_error': self._format_system_error\n        }\n        \n        formatter = formatters.get(alert_type)\n        if formatter:\n            return formatter(data)\n        return None\n    \n    def _format_signal_received(self, data: Dict[str, Any]) -> str:\n        \"\"\"Format signal received alert\"\"\"\n        return f\"\"\"ğŸ“¥ *SIGNAL RECEIVED*\n\n*Type:* {data['signal_type']}\n*Instrument:* {data['instrument']}\n*Position:* {data['position']}\n*Price:* â‚¹{data['price']:,.2f}\n*Time:* {data['timestamp']}\n\"\"\"\n    \n    def _format_signal_rejected(self, data: Dict[str, Any]) -> str:\n        \"\"\"Format signal rejected alert\"\"\"\n        return f\"\"\"â›” *SIGNAL REJECTED*\n\n*Instrument:* {data['instrument']}\n*Type:* {data['signal_type']}\n*Time:* {data['timestamp']}\n\n*Reason:* `{data['rejection_code']}`\n{data['rejection_reason']}\n\n*Details:*\n{self._format_decision_data(data.get('decision_data', {}))}\n\n_No action taken._\n\"\"\"\n    \n    def _format_order_placed(self, data: Dict[str, Any]) -> str:\n        \"\"\"Format order placed alert\"\"\"\n        return f\"\"\"ğŸ“¤ *ORDER PLACED*\n\n*Action:* {data['action']}\n*Instrument:* {data['instrument']}\n*Lots:* {data['lots']}\n*Order Type:* {data['order_type']}\n*Price:* â‚¹{data['price']:,.2f}\n*Order ID:* {data['order_id']}\n\"\"\"\n    \n    def _format_order_filled(self, data: Dict[str, Any]) -> str:\n        \"\"\"Format order filled alert\"\"\"\n        slippage_emoji = 'âœ…' if abs(data['slippage_pct']) < 0.1 else 'âš ï¸'\n        return f\"\"\"âœ… *ORDER FILLED*\n\n*Instrument:* {data['instrument']}\n*Lots:* {data['lots']}\n*Fill Price:* â‚¹{data['fill_price']:,.2f}\n{slippage_emoji} *Slippage:* {data['slippage_pct']:.3f}%\n*Duration:* {data['execution_duration_ms']}ms\n\"\"\"\n    \n    def _format_order_failed(self, data: Dict[str, Any]) -> str:\n        \"\"\"Format order failed alert\"\"\"\n        return f\"\"\"âŒ *ORDER FAILED*\n\n*Instrument:* {data['instrument']}\n*Action:* {data['action']}\n*Lots:* {data['lots']}\n\n*Reason:* {data['failure_reason']}\n\n_Position not opened._\n\"\"\"\n    \n    def _format_stop_hit(self, data: Dict[str, Any]) -> str:\n        \"\"\"Format stop hit alert\"\"\"\n        pnl_emoji = 'ğŸŸ¢' if data['pnl'] >= 0 else 'ğŸ”´'\n        return f\"\"\"ğŸ›‘ *STOP HIT*\n\n*Instrument:* {data['instrument']}\n*Exit Price:* â‚¹{data['exit_price']:,.2f}\n{pnl_emoji} *P&L:* â‚¹{data['pnl']:,.2f}\n*Duration:* {data['hold_duration']}\n\"\"\"\n    \n    def _format_system_error(self, data: Dict[str, Any]) -> str:\n        \"\"\"Format system error alert\"\"\"\n        return f\"\"\"ğŸš¨ *SYSTEM ERROR*\n\n*Component:* {data['component']}\n*Error:* {data['error_message']}\n*Time:* {data['timestamp']}\n\n_Check logs for details._\n\"\"\"\n    \n    def _format_decision_data(self, decision_data: Dict[str, Any]) -> str:\n        \"\"\"Format decision data for display\"\"\"\n        lines = []\n        for key, value in decision_data.items():\n            if key != 'severity':\n                lines.append(f\"â”œâ”€ {key}: {value}\")\n        return '\\n'.join(lines) if lines else ''\n    \n    async def send_heartbeat(self, status_data: Dict[str, Any]):\n        \"\"\"Send periodic heartbeat message\"\"\"\n        if not self.enabled:\n            return\n        \n        message = f\"\"\"âœ… *PM Heartbeat*\n\n*Time:* {datetime.now().strftime('%H:%M:%S IST')}\n*Status:* {'Running' if status_data['running'] else 'Stopped'}\n*Positions:* {status_data['positions_open']} open\n*Today P&L:* â‚¹{status_data['today_pnl']:,.0f}\n*Last Signal:* {status_data['last_signal_time']} ({status_data['last_signal_outcome']})\n\"\"\"\n        await self._send_message(message)\n\n# Integration with LiveTradingEngine\nclass AlertIntegration:\n    \"\"\"Mixin to integrate alerts into trading engine\"\"\"\n    \n    def __init__(self, alert_publisher: TelegramAlertPublisher):\n        self.alerts = alert_publisher\n    \n    async def notify_signal_received(self, signal: Dict[str, Any]):\n        await self.alerts.send_alert('signal_received', {\n            'signal_type': signal['type'],\n            'instrument': signal['instrument'],\n            'position': signal['position'],\n            'price': signal['price'],\n            'timestamp': signal['timestamp']\n        })\n    \n    async def notify_signal_rejected(self, signal: Dict[str, Any], rejection: Dict[str, Any]):\n        await self.alerts.send_alert('signal_rejected', {\n            'instrument': signal['instrument'],\n            'signal_type': signal['type'],\n            'timestamp': signal['timestamp'],\n            'rejection_code': rejection['rejection_code'],\n            'rejection_reason': rejection['rejection_reason'],\n            'decision_data': rejection.get('decision_data', {})\n        })\n    \n    async def notify_order_placed(self, order: Dict[str, Any]):\n        await self.alerts.send_alert('order_placed', order)\n    \n    async def notify_order_filled(self, order: Dict[str, Any]):\n        await self.alerts.send_alert('order_filled', order)\n    \n    async def notify_order_failed(self, order: Dict[str, Any]):\n        await self.alerts.send_alert('order_failed', order)\n    \n    async def notify_stop_hit(self, position: Dict[str, Any]):\n        await self.alerts.send_alert('stop_hit', position)\n    \n    async def notify_system_error(self, component: str, error: Exception):\n        await self.alerts.send_alert('system_error', {\n            'component': component,\n            'error_message': str(error),\n            'timestamp': datetime.now().isoformat()\n        })\n```",
        "testStrategy": "1. Test send_alert respects alert_config enable/disable flags\n2. Test each alert formatter produces correct markdown format\n3. Test _format_signal_rejected includes decision_data\n4. Test _format_order_filled shows slippage with correct emoji\n5. Test _format_stop_hit shows P&L with correct emoji\n6. Test send_heartbeat formats status correctly\n7. Test rate limiting with multiple rapid alerts\n8. Test error handling when Telegram API fails\n9. Integration test: trigger alerts from LiveTradingEngine\n10. Test AlertIntegration mixin methods call correct formatters\n11. Verify messages render correctly in Telegram client",
        "priority": "medium",
        "dependencies": [
          "46"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "48",
        "title": "Implement Heartbeat Scheduler",
        "description": "Create scheduled task to send periodic heartbeat messages to Telegram during market hours with system health status",
        "details": "Create core/heartbeat_scheduler.py:\n\n```python\nimport asyncio\nimport logging\nfrom datetime import datetime, time\nfrom typing import Optional\nfrom core.telegram_alerts import TelegramAlertPublisher\n\nlogger = logging.getLogger(__name__)\n\nclass HeartbeatScheduler:\n    def __init__(self, config, alert_publisher: TelegramAlertPublisher, status_provider):\n        self.config = config\n        self.alerts = alert_publisher\n        self.status_provider = status_provider\n        self.interval_seconds = config['telegram'].get('heartbeat_interval_seconds', 300)  # 5 minutes\n        self.enabled = config['telegram'].get('enabled', True)\n        self.running = False\n        self.task: Optional[asyncio.Task] = None\n        \n        # Market hours (IST)\n        self.market_open_time = time(9, 15)  # 09:15 AM\n        self.market_close_time = time(15, 30)  # 03:30 PM\n    \n    async def start(self):\n        \"\"\"Start heartbeat scheduler\"\"\"\n        if not self.enabled:\n            logger.info(\"Heartbeat scheduler disabled\")\n            return\n        \n        self.running = True\n        self.task = asyncio.create_task(self._heartbeat_loop())\n        logger.info(f\"Heartbeat scheduler started (interval: {self.interval_seconds}s)\")\n    \n    async def stop(self):\n        \"\"\"Stop heartbeat scheduler\"\"\"\n        self.running = False\n        if self.task:\n            self.task.cancel()\n            try:\n                await self.task\n            except asyncio.CancelledError:\n                pass\n        logger.info(\"Heartbeat scheduler stopped\")\n    \n    async def _heartbeat_loop(self):\n        \"\"\"Main heartbeat loop\"\"\"\n        while self.running:\n            try:\n                # Check if market is open\n                if self._is_market_hours():\n                    await self._send_heartbeat()\n                else:\n                    logger.debug(\"Skipping heartbeat - market closed\")\n                \n                # Wait for next interval\n                await asyncio.sleep(self.interval_seconds)\n                \n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                logger.error(f\"Error in heartbeat loop: {e}\")\n                await asyncio.sleep(60)  # Wait 1 minute before retry\n    \n    def _is_market_hours(self) -> bool:\n        \"\"\"Check if current time is within market hours\"\"\"\n        now = datetime.now().time()\n        return self.market_open_time <= now <= self.market_close_time\n    \n    async def _send_heartbeat(self):\n        \"\"\"Send heartbeat message\"\"\"\n        try:\n            status_data = self._get_status_data()\n            await self.alerts.send_heartbeat(status_data)\n            logger.debug(\"Heartbeat sent\")\n        except Exception as e:\n            logger.error(f\"Failed to send heartbeat: {e}\")\n    \n    def _get_status_data(self) -> dict:\n        \"\"\"Get current system status for heartbeat\"\"\"\n        # Query status from status_provider (LiveTradingEngine or similar)\n        status = self.status_provider.get_current_status()\n        \n        return {\n            'running': status.get('running', True),\n            'positions_open': status.get('positions_open', 0),\n            'today_pnl': status.get('today_pnl', 0.0),\n            'last_signal_time': status.get('last_signal_time', 'N/A'),\n            'last_signal_outcome': status.get('last_signal_outcome', 'N/A')\n        }\n    \n    async def send_immediate_heartbeat(self):\n        \"\"\"Send heartbeat immediately (for testing or manual trigger)\"\"\"\n        await self._send_heartbeat()\n\n# Integration with main application\nclass HeartbeatMonitor:\n    \"\"\"Monitor for missing heartbeats (optional - for external monitoring)\"\"\"\n    \n    def __init__(self, expected_interval_seconds: int = 300, tolerance_seconds: int = 60):\n        self.expected_interval = expected_interval_seconds\n        self.tolerance = tolerance_seconds\n        self.last_heartbeat: Optional[datetime] = None\n    \n    def record_heartbeat(self):\n        \"\"\"Record that a heartbeat was received\"\"\"\n        self.last_heartbeat = datetime.now()\n    \n    def is_heartbeat_missing(self) -> bool:\n        \"\"\"Check if heartbeat is overdue\"\"\"\n        if not self.last_heartbeat:\n            return False\n        \n        elapsed = (datetime.now() - self.last_heartbeat).total_seconds()\n        return elapsed > (self.expected_interval + self.tolerance)\n    \n    def get_time_since_last_heartbeat(self) -> Optional[float]:\n        \"\"\"Get seconds since last heartbeat\"\"\"\n        if not self.last_heartbeat:\n            return None\n        return (datetime.now() - self.last_heartbeat).total_seconds()\n```\n\nUpdate portfolio_manager.py to integrate heartbeat:\n\n```python\nfrom core.heartbeat_scheduler import HeartbeatScheduler\n\nclass PortfolioManager:\n    def __init__(self, config):\n        # ... existing initialization ...\n        self.heartbeat_scheduler = HeartbeatScheduler(\n            config=config,\n            alert_publisher=self.telegram_alerts,\n            status_provider=self.trading_engine\n        )\n    \n    async def start(self):\n        # ... existing startup ...\n        await self.heartbeat_scheduler.start()\n    \n    async def stop(self):\n        await self.heartbeat_scheduler.stop()\n        # ... existing shutdown ...\n```",
        "testStrategy": "1. Test start() initializes heartbeat loop correctly\n2. Test _is_market_hours returns True during market hours (9:15-15:30 IST)\n3. Test _is_market_hours returns False outside market hours\n4. Test heartbeat skipped when market closed\n5. Test heartbeat sent at correct intervals during market hours\n6. Test _get_status_data queries status_provider correctly\n7. Test send_immediate_heartbeat sends without waiting for interval\n8. Test stop() cancels running task cleanly\n9. Test error handling in heartbeat loop continues after error\n10. Test HeartbeatMonitor detects missing heartbeats\n11. Integration test: run scheduler for multiple intervals and verify messages sent\n12. Test timezone handling for IST market hours",
        "priority": "medium",
        "dependencies": [
          "47"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "49",
        "title": "Create Telegram Configuration and Bot Initialization",
        "description": "Create telegram_config.json configuration file and integrate bot initialization into main Portfolio Manager startup sequence",
        "details": "Create telegram_config.json:\n\n```json\n{\n  \"telegram\": {\n    \"bot_token\": \"YOUR_BOT_TOKEN_HERE\",\n    \"chat_id\": \"YOUR_CHAT_ID_HERE\",\n    \"enabled\": true,\n    \"heartbeat_interval_seconds\": 300,\n    \"alerts\": {\n      \"signal_received\": true,\n      \"signal_rejected\": true,\n      \"order_placed\": true,\n      \"order_filled\": true,\n      \"order_failed\": true,\n      \"stop_hit\": true,\n      \"system_error\": true\n    }\n  }\n}\n```\n\nUpdate portfolio_manager.py:\n\n```python\nimport asyncio\nimport json\nimport logging\nfrom pathlib import Path\nfrom core.telegram_bot import PMTelegramBot\nfrom core.telegram_alerts import TelegramAlertPublisher, AlertIntegration\nfrom core.heartbeat_scheduler import HeartbeatScheduler\n\nlogger = logging.getLogger(__name__)\n\nclass PortfolioManager:\n    def __init__(self, config_path: str = 'config.json'):\n        # Load main config\n        self.config = self._load_config(config_path)\n        \n        # Load Telegram config\n        telegram_config_path = Path(config_path).parent / 'telegram_config.json'\n        if telegram_config_path.exists():\n            telegram_config = self._load_config(str(telegram_config_path))\n            self.config.update(telegram_config)\n        else:\n            logger.warning(\"telegram_config.json not found, Telegram features disabled\")\n            self.config['telegram'] = {'enabled': False}\n        \n        # Initialize components\n        self.db_manager = DatabaseStateManager(self.config)\n        self.signal_validator = SignalValidator(self.config)\n        self.position_sizer = PositionSizer(self.config)\n        self.order_executor = OrderExecutor(self.config)\n        \n        # Initialize audit services\n        self.audit_service = SignalAuditService(self.db_manager)\n        self.order_logger = OrderExecutionLogger(self.db_manager)\n        \n        # Initialize Telegram components\n        self.telegram_alerts = TelegramAlertPublisher(self.config)\n        self.telegram_bot = PMTelegramBot(\n            config=self.config,\n            db_manager=self.db_manager,\n            audit_service=self.audit_service,\n            order_logger=self.order_logger\n        )\n        \n        # Initialize trading engine with alert integration\n        self.trading_engine = LiveTradingEngine(\n            config=self.config,\n            db_manager=self.db_manager,\n            signal_validator=self.signal_validator,\n            position_sizer=self.position_sizer,\n            order_executor=self.order_executor\n        )\n        self.alert_integration = AlertIntegration(self.telegram_alerts)\n        \n        # Initialize heartbeat scheduler\n        self.heartbeat_scheduler = HeartbeatScheduler(\n            config=self.config,\n            alert_publisher=self.telegram_alerts,\n            status_provider=self.trading_engine\n        )\n        \n        self.running = False\n    \n    def _load_config(self, path: str) -> dict:\n        \"\"\"Load configuration from JSON file\"\"\"\n        with open(path, 'r') as f:\n            return json.load(f)\n    \n    async def start(self):\n        \"\"\"Start Portfolio Manager with all components\"\"\"\n        logger.info(\"Starting Portfolio Manager...\")\n        \n        try:\n            # Start database connection\n            self.db_manager.connect()\n            \n            # Start Telegram bot\n            if self.config['telegram'].get('enabled', False):\n                await self.telegram_bot.start()\n                logger.info(\"Telegram bot started\")\n            \n            # Start heartbeat scheduler\n            await self.heartbeat_scheduler.start()\n            \n            # Start trading engine\n            self.trading_engine.start()\n            \n            self.running = True\n            logger.info(\"Portfolio Manager started successfully\")\n            \n            # Send startup notification\n            if self.config['telegram'].get('enabled', False):\n                await self.telegram_alerts.send_alert('system_error', {\n                    'component': 'PortfolioManager',\n                    'error_message': 'System started successfully',\n                    'timestamp': datetime.now().isoformat()\n                })\n            \n        except Exception as e:\n            logger.error(f\"Failed to start Portfolio Manager: {e}\")\n            await self.stop()\n            raise\n    \n    async def stop(self):\n        \"\"\"Stop Portfolio Manager gracefully\"\"\"\n        logger.info(\"Stopping Portfolio Manager...\")\n        \n        self.running = False\n        \n        # Stop heartbeat scheduler\n        await self.heartbeat_scheduler.stop()\n        \n        # Stop trading engine\n        self.trading_engine.stop()\n        \n        # Stop Telegram bot\n        if self.telegram_bot.application:\n            await self.telegram_bot.application.stop()\n            await self.telegram_bot.application.shutdown()\n        \n        # Close database connection\n        self.db_manager.disconnect()\n        \n        logger.info(\"Portfolio Manager stopped\")\n    \n    async def process_webhook_signal(self, signal_data: dict) -> dict:\n        \"\"\"Process incoming webhook signal with alerts\"\"\"\n        try:\n            # Notify signal received\n            await self.alert_integration.notify_signal_received(signal_data)\n            \n            # Process signal\n            result = self.trading_engine.process_signal(signal_data)\n            \n            # Send appropriate alert based on result\n            if result['status'] == 'rejected':\n                await self.alert_integration.notify_signal_rejected(\n                    signal_data,\n                    result.get('rejection', {})\n                )\n            elif result['status'] == 'processed':\n                if result.get('order_result', {}).get('status') == 'SUCCESS':\n                    await self.alert_integration.notify_order_filled(\n                        result['order_result']\n                    )\n                else:\n                    await self.alert_integration.notify_order_failed(\n                        result['order_result']\n                    )\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error processing signal: {e}\")\n            await self.alert_integration.notify_system_error('SignalProcessing', e)\n            raise\n\n# Main entry point\nasync def main():\n    pm = PortfolioManager('config.json')\n    \n    try:\n        await pm.start()\n        \n        # Keep running\n        while pm.running:\n            await asyncio.sleep(1)\n            \n    except KeyboardInterrupt:\n        logger.info(\"Received shutdown signal\")\n    finally:\n        await pm.stop()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\nCreate setup script for Telegram bot:\n\n```python\n# scripts/setup_telegram_bot.py\nimport json\nfrom telegram import Bot\nimport asyncio\n\nasync def setup_telegram_bot():\n    \"\"\"Interactive setup for Telegram bot\"\"\"\n    print(\"=== Telegram Bot Setup ===\")\n    print()\n    print(\"1. Create a bot with @BotFather on Telegram\")\n    print(\"2. Get your bot token\")\n    print(\"3. Start a chat with your bot\")\n    print(\"4. Get your chat ID by sending /start to @userinfobot\")\n    print()\n    \n    bot_token = input(\"Enter your bot token: \").strip()\n    chat_id = input(\"Enter your chat ID: \").strip()\n    \n    # Test connection\n    print(\"\\nTesting connection...\")\n    try:\n        bot = Bot(token=bot_token)\n        me = await bot.get_me()\n        print(f\"âœ… Bot connected: @{me.username}\")\n        \n        # Send test message\n        await bot.send_message(\n            chat_id=chat_id,\n            text=\"ğŸ¤– *PM Telegram Bot Setup*\\n\\nConnection successful!\",\n            parse_mode='Markdown'\n        )\n        print(f\"âœ… Test message sent to chat {chat_id}\")\n        \n        # Save configuration\n        config = {\n            \"telegram\": {\n                \"bot_token\": bot_token,\n                \"chat_id\": chat_id,\n                \"enabled\": True,\n                \"heartbeat_interval_seconds\": 300,\n                \"alerts\": {\n                    \"signal_received\": True,\n                    \"signal_rejected\": True,\n                    \"order_placed\": True,\n                    \"order_filled\": True,\n                    \"order_failed\": True,\n                    \"stop_hit\": True,\n                    \"system_error\": True\n                }\n            }\n        }\n        \n        with open('telegram_config.json', 'w') as f:\n            json.dump(config, f, indent=2)\n        \n        print(\"\\nâœ… Configuration saved to telegram_config.json\")\n        print(\"\\nYou can now start the Portfolio Manager with Telegram integration!\")\n        \n    except Exception as e:\n        print(f\"\\nâŒ Error: {e}\")\n        print(\"Please check your bot token and chat ID\")\n\nif __name__ == '__main__':\n    asyncio.run(setup_telegram_bot())\n```",
        "testStrategy": "1. Test telegram_config.json loads correctly\n2. Test PortfolioManager initializes with Telegram disabled when config missing\n3. Test PortfolioManager initializes all Telegram components when enabled\n4. Test start() sequence: DB -> Bot -> Heartbeat -> Engine\n5. Test stop() sequence: Heartbeat -> Engine -> Bot -> DB\n6. Test process_webhook_signal sends appropriate alerts\n7. Test startup notification sent when system starts\n8. Test error notification sent when signal processing fails\n9. Run setup_telegram_bot.py script and verify configuration created\n10. Test bot connection with test message\n11. Integration test: start PM, send webhook, verify alerts received\n12. Test graceful shutdown with Ctrl+C",
        "priority": "medium",
        "dependencies": [
          "46",
          "47",
          "48"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "50",
        "title": "Add Dependencies and Create Comprehensive Test Suite",
        "description": "Add python-telegram-bot dependency, create unit and integration tests for all audit trail and Telegram bot functionality, and update documentation",
        "details": "Update requirements.txt:\n\n```\npython-telegram-bot>=20.7\naiohttp>=3.9.0\n```\n\nCreate tests/test_signal_audit.py:\n\n```python\nimport pytest\nfrom datetime import datetime\nfrom core.signal_audit_service import SignalAuditService, SignalAuditRecord, SignalOutcome\n\nclass TestSignalAuditService:\n    def test_create_audit_record(self, db_manager):\n        service = SignalAuditService(db_manager)\n        record = SignalAuditRecord(\n            signal_fingerprint='test123',\n            instrument='BANK_NIFTY',\n            signal_type='ENTRY',\n            position='LONG',\n            signal_timestamp=datetime.now(),\n            received_at=datetime.now(),\n            outcome=SignalOutcome.PROCESSED\n        )\n        audit_id = service.create_audit_record(record)\n        assert audit_id > 0\n    \n    def test_get_audit_by_fingerprint(self, db_manager):\n        service = SignalAuditService(db_manager)\n        # Create record\n        record = SignalAuditRecord(\n            signal_fingerprint='test456',\n            instrument='BANK_NIFTY',\n            signal_type='ENTRY',\n            position='LONG',\n            signal_timestamp=datetime.now(),\n            received_at=datetime.now(),\n            outcome=SignalOutcome.PROCESSED\n        )\n        service.create_audit_record(record)\n        \n        # Retrieve\n        retrieved = service.get_audit_by_fingerprint('test456')\n        assert retrieved is not None\n        assert retrieved['instrument'] == 'BANK_NIFTY'\n```\n\nCreate tests/test_telegram_bot.py:\n\n```python\nimport pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom core.telegram_bot import PMTelegramBot\nfrom telegram import Update\n\nclass TestPMTelegramBot:\n    @pytest.mark.asyncio\n    async def test_status_command(self, mock_config, mock_db):\n        bot = PMTelegramBot(mock_config, mock_db, Mock(), Mock())\n        update = Mock(spec=Update)\n        update.effective_chat.id = mock_config['telegram']['chat_id']\n        update.message.reply_text = AsyncMock()\n        \n        await bot.cmd_status(update, Mock())\n        \n        update.message.reply_text.assert_called_once()\n        args = update.message.reply_text.call_args\n        assert 'PM Status' in args[0][0]\n    \n    @pytest.mark.asyncio\n    async def test_unauthorized_access(self, mock_config, mock_db):\n        bot = PMTelegramBot(mock_config, mock_db, Mock(), Mock())\n        update = Mock(spec=Update)\n        update.effective_chat.id = '999999'  # Wrong chat ID\n        update.message.reply_text = AsyncMock()\n        \n        await bot.cmd_status(update, Mock())\n        \n        update.message.reply_text.assert_called_once_with(\"â›” Unauthorized\")\n```\n\nCreate tests/test_integration.py:\n\n```python\nimport pytest\nimport asyncio\nfrom portfolio_manager import PortfolioManager\n\nclass TestIntegration:\n    @pytest.mark.asyncio\n    async def test_full_signal_flow_with_alerts(self, test_config):\n        \"\"\"Test complete signal processing with audit trail and alerts\"\"\"\n        pm = PortfolioManager(test_config)\n        \n        try:\n            await pm.start()\n            \n            # Send test signal\n            signal = {\n                'instrument': 'BANK_NIFTY',\n                'type': 'ENTRY',\n                'position': 'LONG',\n                'price': 52145.00,\n                'timestamp': datetime.now().isoformat(),\n                'stop_distance': 245.50\n            }\n            \n            result = await pm.process_webhook_signal(signal)\n            \n            # Verify audit record created\n            assert result['audit_id'] is not None\n            \n            # Verify order logged\n            orders = pm.order_logger.get_orders_by_signal(result['audit_id'])\n            assert len(orders) > 0\n            \n        finally:\n            await pm.stop()\n    \n    @pytest.mark.asyncio\n    async def test_heartbeat_during_market_hours(self, test_config):\n        \"\"\"Test heartbeat sends during market hours\"\"\"\n        pm = PortfolioManager(test_config)\n        \n        try:\n            await pm.start()\n            \n            # Trigger immediate heartbeat\n            await pm.heartbeat_scheduler.send_immediate_heartbeat()\n            \n            # Verify message sent (check mock or logs)\n            \n        finally:\n            await pm.stop()\n```\n\nCreate tests/test_position_sizer.py:\n\n```python\nimport pytest\nfrom core.position_sizer import PositionSizer, SizingMethod, Limiter\n\nclass TestPositionSizer:\n    def test_tom_basso_calculation(self):\n        config = {'max_lots_per_trade': 10, 'min_lots': 1}\n        sizer = PositionSizer(config)\n        \n        result = sizer.calculate_position_size(\n            equity_high=5200000,\n            risk_percent=1.0,\n            stop_distance=245.50,\n            lot_size=15,\n            point_value=30,\n            efficiency_ratio=0.72,\n            atr=312.45\n        )\n        \n        assert result.sizing_method == SizingMethod.TOM_BASSO\n        assert result.final_lots > 0\n        assert result.limiter in [Limiter.RISK, Limiter.MAX_LOTS]\n        assert len(result.constraints_applied) > 0\n    \n    def test_max_lots_constraint(self):\n        config = {'max_lots_per_trade': 2, 'min_lots': 1}\n        sizer = PositionSizer(config)\n        \n        result = sizer.calculate_position_size(\n            equity_high=10000000,  # Very high equity\n            risk_percent=5.0,\n            stop_distance=100,\n            lot_size=15,\n            point_value=30,\n            efficiency_ratio=1.0,\n            atr=200\n        )\n        \n        assert result.final_lots == 2  # Capped at max_lots\n        assert result.limiter == Limiter.MAX_LOTS\n```\n\nCreate documentation:\n\n```markdown\n# PM Signal Audit Trail & Telegram Bot - User Guide\n\n## Setup\n\n### 1. Database Migration\n\n```bash\npsql -U postgres -d portfolio_manager -f migrations/010_signal_audit.sql\npsql -U postgres -d portfolio_manager -f migrations/011_order_execution_log.sql\n```\n\n### 2. Telegram Bot Setup\n\n```bash\npython scripts/setup_telegram_bot.py\n```\n\nFollow the prompts to configure your bot.\n\n### 3. Install Dependencies\n\n```bash\npip install -r requirements.txt\n```\n\n### 4. Start Portfolio Manager\n\n```bash\npython portfolio_manager.py\n```\n\n## Using Telegram Commands\n\n### Query Commands\n\n- `/status` - View system status\n- `/positions` - View open positions\n- `/signals` - View recent signals\n- `/signal <fingerprint>` - View detailed signal audit\n- `/pnl` - View P&L summary\n- `/equity` - View portfolio equity\n- `/risk` - View risk exposure\n- `/orders` - View today's orders\n- `/ping` - Check bot responsiveness\n- `/help` - List all commands\n\n### Alerts\n\nYou will automatically receive alerts for:\n- Signal received\n- Signal rejected (with reason)\n- Order placed\n- Order filled (with slippage)\n- Order failed\n- Stop hit\n- System errors\n\n### Heartbeat\n\nDuring market hours (9:15 AM - 3:30 PM IST), you will receive a heartbeat message every 5 minutes showing:\n- System status\n- Open positions\n- Today's P&L\n- Last signal processed\n\n## Querying Audit Trail\n\n### SQL Queries\n\n```sql\n-- Get all signals for an instrument\nSELECT * FROM signal_audit \nWHERE instrument = 'BANK_NIFTY' \nORDER BY signal_timestamp DESC;\n\n-- Get rejected signals with reasons\nSELECT instrument, signal_type, outcome, outcome_reason \nFROM signal_audit \nWHERE outcome LIKE 'REJECTED%'\nORDER BY created_at DESC;\n\n-- Get position sizing details\nSELECT \n    instrument,\n    sizing_calculation->>'final_lots' as lots,\n    sizing_calculation->>'limiter' as limiter\nFROM signal_audit\nWHERE outcome = 'PROCESSED';\n\n-- Get order execution with slippage\nSELECT \n    o.instrument,\n    o.fill_price,\n    o.slippage_pct,\n    o.execution_duration_ms\nFROM order_execution_log o\nWHERE o.order_status = 'COMPLETE'\nORDER BY o.order_filled_at DESC;\n```\n\n## Troubleshooting\n\n### Bot Not Responding\n\n1. Check `telegram_config.json` has correct bot_token and chat_id\n2. Verify bot is enabled: `\"enabled\": true`\n3. Check logs for connection errors\n4. Test with `/ping` command\n\n### Missing Alerts\n\n1. Check alert configuration in `telegram_config.json`\n2. Verify specific alert type is enabled\n3. Check Telegram API rate limits\n\n### Heartbeat Not Received\n\n1. Verify current time is within market hours (9:15 AM - 3:30 PM IST)\n2. Check heartbeat_interval_seconds in config\n3. Check logs for scheduler errors\n\n## Configuration Reference\n\n```json\n{\n  \"telegram\": {\n    \"bot_token\": \"<YOUR_BOT_TOKEN>\",\n    \"chat_id\": \"<YOUR_CHAT_ID>\",\n    \"enabled\": true,\n    \"heartbeat_interval_seconds\": 300,\n    \"alerts\": {\n      \"signal_received\": true,\n      \"signal_rejected\": true,\n      \"order_placed\": true,\n      \"order_filled\": true,\n      \"order_failed\": true,\n      \"stop_hit\": true,\n      \"system_error\": true\n    }\n  }\n}\n```\n```",
        "testStrategy": "1. Run pytest on all test files and verify 100% pass rate\n2. Test database migrations apply cleanly on fresh database\n3. Test setup_telegram_bot.py script creates valid configuration\n4. Test all unit tests for SignalAuditService\n5. Test all unit tests for PositionSizer\n6. Test all unit tests for Telegram bot commands\n7. Test integration test for full signal flow\n8. Test integration test for heartbeat\n9. Verify documentation is complete and accurate\n10. Test SQL queries in documentation return expected results\n11. Perform end-to-end test: start PM, send signals, verify alerts, query via Telegram\n12. Load test: send 100 signals rapidly and verify all audited correctly",
        "priority": "medium",
        "dependencies": [
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-06T16:30:10.102Z",
      "taskCount": 11,
      "completedCount": 1,
      "tags": [
        "master"
      ]
    }
  }
}