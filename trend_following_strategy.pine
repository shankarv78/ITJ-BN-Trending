//@version=5
strategy("Trend Following Strategy",
     overlay=true,
     pyramiding=3,
     initial_capital=5000000,
     default_qty_type=strategy.fixed,
     default_qty_value=1,
     calc_on_every_tick=true,
     calc_on_order_fills=false,
     process_orders_on_close=true,
     commission_type=strategy.commission.percent,
     commission_value=0.1)

// ========================================
// PARAMETERS
// ========================================

// RSI Parameters
rsi_period = input.int(6, "RSI Period", minval=1)
rsi_threshold = input.float(70, "RSI Threshold", minval=0, maxval=100)

// EMA Parameters
ema_period = input.int(200, "EMA Period", minval=1)

// Donchian Channel Parameters
dc_period = input.int(20, "DC Period", minval=1)

// ADX Parameters
adx_period = input.int(30, "ADX Period", minval=1)
adx_threshold = input.float(25, "ADX Threshold", minval=0)

// Efficiency Ratio Parameters (as per provided code)
er_period = input.int(3, "ER Period", minval=1)
er_directional = input.bool(false, "ER Directional")
er_threshold = input.float(0.8, "ER Threshold", minval=0, maxval=1)

// SuperTrend Parameters
st_period = input.int(10, "ST Period", minval=1)
st_multiplier = input.float(1.5, "ST Multiplier", minval=0.1, step=0.1)

// Doji Detection Parameter
doji_threshold = input.float(0.1, "Doji Body/Range Ratio", minval=0.01, maxval=0.3, step=0.01, tooltip="Body size as % of candle range. Lower = stricter doji detection")

// Debug Mode
show_debug = input.bool(false, "Show Debug Panel", tooltip="Show detailed condition status in separate pane (not recommended - use info table instead)")

// Indicator Display Options
show_donchian = input.bool(false, "Show Donchian Channel", tooltip="Display DC upper/lower/middle bands on chart")
show_rsi = input.bool(false, "Show RSI", tooltip="Display RSI in separate pane")
show_adx = input.bool(false, "Show ADX", tooltip="Display ADX in separate pane")
show_er = input.bool(false, "Show Efficiency Ratio", tooltip="Display ER in separate pane")
show_atr = input.bool(false, "Show ATR", tooltip="Display ATR in separate pane")

// Info Panel Display Mode
smart_panel = input.bool(true, "Smart Info Panel", tooltip="Show indicators when flat, trade info when in position")
show_all_info = input.bool(false, "Show All Info (Debug)", tooltip="Show both indicators and trade info always (for debugging)")

// Position Sizing Parameters
risk_percent = input.float(2.0, "Risk % of Capital", minval=0.1, maxval=10, step=0.1, tooltip="Percentage of capital to risk per trade")
lot_size = input.int(35, "Lot Size", minval=1, tooltip="Contract lot size (Bank Nifty = 15, but using 35 as specified)")

// Margin Management (for Synthetic Futures: ATM PE Sell + ATM CE Buy)
use_margin_check = input.bool(true, "Enable Margin Check", tooltip="Prevent pyramiding if insufficient margin available")
max_margin_available = input.float(50.0, "Max Margin Available (Lakhs)", minval=1, step=1, tooltip="Total margin available for trading (in lakhs)")
margin_per_lot = input.float(2.6, "Margin per Lot (Lakhs)", minval=0.1, step=0.1, tooltip="Approximate margin required per lot for synthetic future (ATM PE Sell + CE Buy)")

// Pyramiding Parameters
enable_pyramiding = input.bool(true, "Enable Pyramiding", tooltip="Allow adding to winning positions")
max_pyramids = input.int(3, "Max Pyramids", minval=1, maxval=3, tooltip="Maximum number of pyramid entries (3 = 4 total positions)")
atr_pyramid_threshold = input.float(0.5, "ATR Pyramid Threshold", minval=0.25, maxval=2.0, step=0.25, tooltip="ATR multiplier for pyramid triggers (0.5 = add every 0.5 ATR move)")
pyramid_size_ratio = input.float(0.5, "Pyramid Size Ratio", minval=0.25, maxval=1.0, step=0.05, tooltip="Size of each pyramid as ratio of previous entry (0.5 = 50%)")

// Stop Loss Management
stop_loss_mode = input.string("SuperTrend", "Stop Loss Mode", options=["SuperTrend", "Van Tharp", "Tom Basso"], tooltip="SuperTrend: All entries use ST as SL | Van Tharp: Trail previous entries to breakeven | Tom Basso: ATR-based trailing stop")
atr_period_pyramid = input.int(10, "ATR Period (Pyramiding)", minval=1, tooltip="ATR period for calculating pyramid triggers")

// Tom Basso ATR Trailing Stop Parameters (only used if mode = "Tom Basso")
basso_initial_atr_mult = input.float(1.0, "Basso Initial Stop (× ATR)", minval=0.5, maxval=5.0, step=0.5, tooltip="Initial stop distance from entry (multiplier of ATR)")
basso_trailing_atr_mult = input.float(2.0, "Basso Trailing Stop (× ATR)", minval=1.0, maxval=5.0, step=0.5, tooltip="Trailing stop distance from highest close (multiplier of ATR)")
basso_atr_period = input.int(10, "Basso ATR Period", minval=5, maxval=50, tooltip="ATR period for Tom Basso stop calculation")

// Trade Start Date Filter
use_start_date = input.bool(true, "Use Start Date Filter", tooltip="Only allow trades from specified date onwards")
start_date = input.time(timestamp("11 Nov 2025 00:00 +0000"), "Trade Start Date", tooltip="Strategy will only take trades from this date onwards")

// ========================================
// INDICATOR CALCULATIONS
// ========================================

// RSI
rsi = ta.rsi(close, rsi_period)

// EMA
ema = ta.ema(close, ema_period)

// Donchian Channel (Upper band only for entry condition)
// Use [1] offset to check against PREVIOUS period's high, not including current bar
dc_upper = ta.highest(high[1], dc_period)
dc_lower = ta.lowest(low[1], dc_period)
dc_middle = (dc_upper + dc_lower) / 2

// ADX Calculation
[diPlus, diMinus, adx] = ta.dmi(adx_period, adx_period)

// Efficiency Ratio (Using exact code provided by user)
ER(src, p, dir) =>
    a = dir ? src - src[p] : math.abs(src - src[p])
    b = 0.0
    for i = 0 to p-1
        b := b + math.abs(src[i] - src[i+1])
    result = b != 0 ? a / b : 0
    result

er = ER(close, er_period, er_directional)

// SuperTrend (10, 1.5)
[supertrend, direction] = ta.supertrend(st_multiplier, st_period)

// ATR for Pyramiding
atr_pyramid = ta.atr(atr_period_pyramid)

// ATR for Tom Basso Mode
atr_basso = ta.atr(basso_atr_period)

// Doji Detection
// A doji has a very small body relative to the candle's range
body_size = math.abs(close - open)
candle_range = high - low
is_doji = candle_range > 0 ? (body_size / candle_range) <= doji_threshold : false

// End-of-Day Detection (for gap-up capture)
// 75-min timeframe: ~5 candles per day (9:15 AM - 3:30 PM = 375 min / 75 = 5 candles)
// Last candle typically closes around 3:30 PM (15:30 or 1530 in session format)
is_eod_candle = hour(time) >= 14 and minute(time) >= 15  // After 2:15 PM
is_market_close = hour(time) == 15 and minute(time) >= 15  // After 3:15 PM (near close)

// ========================================
// STRATEGY CONDITIONS
// ========================================

// Entry Conditions (ALL must be true at candle close)
rsi_condition = rsi > rsi_threshold
ema_condition = close > ema
dc_condition = close > dc_upper
adx_condition = adx < adx_threshold
er_condition = er > er_threshold
st_condition = close > supertrend  // Price above SuperTrend (bullish)
not_doji = not is_doji  // Candle is NOT a doji

// Date Filter: Only allow trades from start_date onwards
date_filter = use_start_date ? time >= start_date : true

// Combine all conditions for long entry
long_entry = rsi_condition and ema_condition and dc_condition and adx_condition and er_condition and st_condition and not_doji and date_filter

// Exit Condition: Candle closes below SuperTrend
long_exit = close < supertrend

// ========================================
// STRATEGY EXECUTION
// ========================================
// With process_orders_on_close=true:
// - Orders execute at the close of the current bar
// - This captures gap-ups when end-of-day candle triggers entry
// - Entry price = close price of signal bar

// ========================================
// PYRAMIDING & POSITION MANAGEMENT
// ========================================
// Van Tharp Principle: Use unrealized profits from current trade for pyramiding decisions
// Risk Management: For new trades use realized equity, for pyramiding use current trade P&L

var float equity_high = strategy.initial_capital  // Track highest equity reached
var float initial_entry_price = na  // First entry price (Long_1)
var float pyr1_entry_price = na  // Pyramid 1 entry price (Long_2)
var float pyr2_entry_price = na  // Pyramid 2 entry price (Long_3)
var float pyr3_entry_price = na  // Pyramid 3 entry price (Long_4)
var float last_pyramid_price = na  // Most recent pyramid entry price
var int pyramid_count = 0  // Number of pyramids added
var float initial_position_size = 0  // Size of first entry

// Tom Basso Mode: Track stops and highest close for each entry
var float basso_stop_long1 = na
var float basso_stop_long2 = na
var float basso_stop_long3 = na
var float basso_stop_long4 = na
var float highest_close_long1 = na
var float highest_close_long2 = na
var float highest_close_long3 = na
var float highest_close_long4 = na

// Update equity high watermark - ONLY with REALIZED profits (closed trades only)
realized_equity = strategy.initial_capital + strategy.netprofit
if realized_equity > equity_high
    equity_high := realized_equity

// Track current equity separately for display (includes unrealized P&L)
current_equity = strategy.equity

// Calculate unrealized profit from current open position (Van Tharp approach for pyramiding)
// This is the "house money" we can use to justify adding more
unrealized_pnl = strategy.openprofit
// R-multiple: How many times the initial risk we've made in profit
unrealized_pnl_r = strategy.position_size > 0 ? unrealized_pnl / (equity_high * (risk_percent / 100)) : 0

// Margin tracking (for synthetic futures: ATM PE Sell + ATM CE Buy)
current_margin_used_display = strategy.position_size * margin_per_lot
margin_remaining = max_margin_available - current_margin_used_display
margin_utilization_pct = max_margin_available > 0 ? (current_margin_used_display / max_margin_available) * 100 : 0

// Calculate stop loss levels and risk exposure for display
var float display_stop_long1 = na
var float display_stop_long2 = na
var float display_stop_long3 = na
var float display_stop_long4 = na

if strategy.position_size > 0
    if stop_loss_mode == "SuperTrend"
        // All positions use SuperTrend
        display_stop_long1 := not na(initial_entry_price) ? supertrend : na
        display_stop_long2 := not na(pyr1_entry_price) ? supertrend : na
        display_stop_long3 := not na(pyr2_entry_price) ? supertrend : na
        display_stop_long4 := not na(pyr3_entry_price) ? supertrend : na
    else if stop_loss_mode == "Van Tharp"
        // Trail to next pyramid or SuperTrend
        display_stop_long1 := not na(initial_entry_price) ? (not na(pyr1_entry_price) ? pyr1_entry_price : supertrend) : na
        display_stop_long2 := not na(pyr1_entry_price) ? (not na(pyr2_entry_price) ? pyr2_entry_price : supertrend) : na
        display_stop_long3 := not na(pyr2_entry_price) ? (not na(pyr3_entry_price) ? pyr3_entry_price : supertrend) : na
        display_stop_long4 := not na(pyr3_entry_price) ? supertrend : na
    else if stop_loss_mode == "Tom Basso"
        // Individual ATR trailing stops
        display_stop_long1 := basso_stop_long1
        display_stop_long2 := basso_stop_long2
        display_stop_long3 := basso_stop_long3
        display_stop_long4 := basso_stop_long4

// Calculate risk exposure per position (if stopped out)
risk_long1 = not na(initial_entry_price) and not na(display_stop_long1) ? math.max(0, (initial_entry_price - display_stop_long1) * initial_position_size * lot_size) : 0
risk_long2 = not na(pyr1_entry_price) and not na(display_stop_long2) ? math.max(0, (pyr1_entry_price - display_stop_long2) * initial_position_size * pyramid_size_ratio * lot_size) : 0
risk_long3 = not na(pyr2_entry_price) and not na(display_stop_long3) ? math.max(0, (pyr2_entry_price - display_stop_long3) * initial_position_size * math.pow(pyramid_size_ratio, 2) * lot_size) : 0
risk_long4 = not na(pyr3_entry_price) and not na(display_stop_long4) ? math.max(0, (pyr3_entry_price - display_stop_long4) * initial_position_size * math.pow(pyramid_size_ratio, 3) * lot_size) : 0
total_risk_exposure = risk_long1 + risk_long2 + risk_long3 + risk_long4

// INITIAL ENTRY: When all conditions are met and no position exists
if long_entry and strategy.position_size == 0
    // Calculate risk amount (2% of HIGHEST REALIZED equity)
    risk_amount = equity_high * (risk_percent / 100)

    // Entry price and stop
    entry_price = close
    stop_loss = supertrend

    // Risk per lot in points and rupees
    risk_per_point = entry_price - stop_loss
    risk_per_lot = risk_per_point * lot_size

    // Calculate number of lots: (Risk ÷ ((Entry - ST) × Lot_Size)) × ER
    num_lots = risk_per_lot > 0 ? (risk_amount / risk_per_lot) * er : 0
    final_lots = math.max(1, math.round(num_lots))

    // Store initial entry details
    initial_entry_price := close
    last_pyramid_price := close
    pyramid_count := 0
    initial_position_size := final_lots

    // Initialize Tom Basso stop for Long_1
    if stop_loss_mode == "Tom Basso"
        basso_stop_long1 := close - (basso_initial_atr_mult * atr_basso)
        highest_close_long1 := close

    // Enter with calculated lot size
    // Add EOD marker to comment for gap-up tracking
    entry_comment = is_eod_candle ? "EOD-ENTRY-" + str.tostring(final_lots) + "L" : "ENTRY-" + str.tostring(final_lots) + "L"
    strategy.entry("Long_1", strategy.long, qty=final_lots, comment=entry_comment)

// PYRAMIDING: Add to winning positions
// Van Tharp: Only pyramid when current position is profitable (using unrealized profits)
if enable_pyramiding and strategy.position_size > 0 and pyramid_count < max_pyramids
    // Calculate how far price has moved from last entry
    price_move_from_last = close - last_pyramid_price
    atr_moves = price_move_from_last / atr_pyramid

    // Van Tharp condition: Current trade must be profitable to justify pyramiding
    position_is_profitable = unrealized_pnl > 0

    // Margin Check: Calculate current and required margin
    current_margin_used = strategy.position_size * margin_per_lot

    // Calculate pyramid size (geometric scaling)
    previous_size = pyramid_count == 0 ? initial_position_size : initial_position_size * math.pow(pyramid_size_ratio, pyramid_count)
    pyramid_lots = math.max(1, math.round(previous_size * pyramid_size_ratio))
    pyramid_margin_required = pyramid_lots * margin_per_lot
    total_margin_after_pyramid = current_margin_used + pyramid_margin_required

    // Check if sufficient margin available
    margin_available = use_margin_check ? total_margin_after_pyramid <= max_margin_available : true

    // Trigger: Price moved enough AND position is profitable AND sufficient margin
    pyramid_trigger = atr_moves >= atr_pyramid_threshold and position_is_profitable and margin_available

    if pyramid_trigger

        // Update tracking
        pyramid_count := pyramid_count + 1
        last_pyramid_price := close

        // Track individual pyramid entry prices (for Van Tharp mode)
        if pyramid_count == 1
            pyr1_entry_price := close
            // Initialize Tom Basso stop for Long_2
            if stop_loss_mode == "Tom Basso"
                basso_stop_long2 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long2 := close
        else if pyramid_count == 2
            pyr2_entry_price := close
            // Initialize Tom Basso stop for Long_3
            if stop_loss_mode == "Tom Basso"
                basso_stop_long3 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long3 := close
        else if pyramid_count == 3
            pyr3_entry_price := close
            // Initialize Tom Basso stop for Long_4
            if stop_loss_mode == "Tom Basso"
                basso_stop_long4 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long4 := close

        // Enter pyramid
        strategy.entry("Long_" + str.tostring(pyramid_count + 1), strategy.long, qty=pyramid_lots, comment="PYR" + str.tostring(pyramid_count) + "-" + str.tostring(pyramid_lots) + "L")

// STOP LOSS MANAGEMENT
if strategy.position_size > 0
    if stop_loss_mode == "SuperTrend"
        // ========================================
        // Mode 1: SuperTrend (Simple)
        // ========================================
        // All positions use SuperTrend as stop
        if close < supertrend
            strategy.close_all(comment="EXIT - Below ST")
            // Reset tracking
            initial_entry_price := na
            pyr1_entry_price := na
            pyr2_entry_price := na
            pyr3_entry_price := na
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

    else if stop_loss_mode == "Van Tharp"
        // ========================================
        // Mode 2: Van Tharp (Trail to Breakeven)
        // ========================================
        // Trail earlier pyramid entries to the entry price of later pyramids
        // Check each position independently (not based on pyramid_count)

        // Long_1 (Initial Entry): Trail to PYR1 or SuperTrend
        if not na(initial_entry_price)
            if not na(pyr1_entry_price)
                // PYR1 exists above us, trail to it
                if close < pyr1_entry_price
                    strategy.close("Long_1", comment="EXIT - Trail to PYR1")
                    initial_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_1", comment="EXIT - Below ST")
                    initial_entry_price := na

        // Long_2 (PYR1): Trail to PYR2 or SuperTrend
        if not na(pyr1_entry_price)
            if not na(pyr2_entry_price)
                // PYR2 exists above us, trail to it
                if close < pyr2_entry_price
                    strategy.close("Long_2", comment="EXIT - Trail to PYR2")
                    pyr1_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_2", comment="EXIT - Below ST")
                    pyr1_entry_price := na

        // Long_3 (PYR2): Trail to PYR3 or SuperTrend
        if not na(pyr2_entry_price)
            if not na(pyr3_entry_price)
                // PYR3 exists above us, trail to it
                if close < pyr3_entry_price
                    strategy.close("Long_3", comment="EXIT - Trail to PYR3")
                    pyr2_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_3", comment="EXIT - Below ST")
                    pyr2_entry_price := na

        // Long_4 (PYR3): Always trail to SuperTrend (highest level)
        if not na(pyr3_entry_price)
            if close < supertrend
                strategy.close("Long_4", comment="EXIT - Below ST")
                pyr3_entry_price := na

        // If all positions closed, reset everything
        if strategy.position_size == 0
            initial_entry_price := na
            pyr1_entry_price := na
            pyr2_entry_price := na
            pyr3_entry_price := na
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

    else if stop_loss_mode == "Tom Basso"
        // ========================================
        // Mode 3: Tom Basso ATR Trailing Stop
        // ========================================
        // Each position has its own ATR-based trailing stop
        // Stop = max(Initial Stop, Highest Close - Trailing ATR)
        // Using manual tracking instead of ta.highest() to avoid buffer issues

        // Update trailing stops for each position
        // Long_1 (Initial Entry)
        if not na(initial_entry_price)
            // Update highest close since entry
            highest_close_long1 := math.max(highest_close_long1, close)
            // Calculate trailing stop
            trailing_stop_long1 = highest_close_long1 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long1 := math.max(basso_stop_long1, trailing_stop_long1)  // Only move up

            // Exit Long_1 if close below trailing stop
            if close < basso_stop_long1
                strategy.close("Long_1", comment="EXIT - Basso Stop")
                initial_entry_price := na
                basso_stop_long1 := na
                highest_close_long1 := na

        // Long_2 (PYR1)
        if not na(pyr1_entry_price)
            highest_close_long2 := math.max(highest_close_long2, close)
            trailing_stop_long2 = highest_close_long2 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long2 := math.max(basso_stop_long2, trailing_stop_long2)

            if close < basso_stop_long2
                strategy.close("Long_2", comment="EXIT - Basso Stop")
                pyr1_entry_price := na
                basso_stop_long2 := na
                highest_close_long2 := na

        // Long_3 (PYR2)
        if not na(pyr2_entry_price)
            highest_close_long3 := math.max(highest_close_long3, close)
            trailing_stop_long3 = highest_close_long3 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long3 := math.max(basso_stop_long3, trailing_stop_long3)

            if close < basso_stop_long3
                strategy.close("Long_3", comment="EXIT - Basso Stop")
                pyr2_entry_price := na
                basso_stop_long3 := na
                highest_close_long3 := na

        // Long_4 (PYR3)
        if not na(pyr3_entry_price)
            highest_close_long4 := math.max(highest_close_long4, close)
            trailing_stop_long4 = highest_close_long4 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long4 := math.max(basso_stop_long4, trailing_stop_long4)

            if close < basso_stop_long4
                strategy.close("Long_4", comment="EXIT - Basso Stop")
                pyr3_entry_price := na
                basso_stop_long4 := na
                highest_close_long4 := na

        // If all positions closed, reset
        if strategy.position_size == 0
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

// ========================================
// PLOTTING
// ========================================

// Always plot EMA and SuperTrend on main chart
plot(ema, "EMA 200", color=color.blue, linewidth=2, force_overlay=true)
plot(supertrend, "SuperTrend (10,1.5)", color=direction < 0 ? color.new(color.green, 0) : color.new(color.red, 0), linewidth=2, style=plot.style_line, force_overlay=true)

// Optional: Donchian Channel on main chart
plot(show_donchian ? dc_upper : na, "DC Upper", color=color.new(color.green, 0), linewidth=1, style=plot.style_line, force_overlay=true)
plot(show_donchian ? dc_lower : na, "DC Lower", color=color.new(color.red, 0), linewidth=1, style=plot.style_line, force_overlay=true)
plot(show_donchian ? dc_middle : na, "DC Middle", color=color.new(color.gray, 50), linewidth=1, style=plot.style_circles, force_overlay=true)

// Optional: RSI (separate pane - different scale from price)
plot(show_rsi ? rsi : na, "RSI(6)", color=color.new(color.purple, 0), linewidth=2)
hline(show_rsi ? 70 : na, "RSI 70", color=color.new(color.red, 50), linestyle=hline.style_dashed)
hline(show_rsi ? 30 : na, "RSI 30", color=color.new(color.green, 50), linestyle=hline.style_dashed)
hline(show_rsi ? 50 : na, "RSI 50", color=color.new(color.gray, 70), linestyle=hline.style_dotted)

// Optional: ADX (separate pane - different scale from price)
plot(show_adx ? adx : na, "ADX(30)", color=color.new(color.orange, 0), linewidth=2)
hline(show_adx ? 25 : na, "ADX 25", color=color.new(color.orange, 50), linestyle=hline.style_dashed)
hline(show_adx ? 50 : na, "ADX 50", color=color.new(color.red, 50), linestyle=hline.style_dotted)

// Optional: Efficiency Ratio (separate pane - different scale from price)
plot(show_er ? er : na, "ER(3)", color=color.new(color.blue, 0), linewidth=2)
hline(show_er ? 0.8 : na, "ER 0.8", color=color.new(color.green, 50), linestyle=hline.style_dashed)
hline(show_er ? 0.5 : na, "ER 0.5", color=color.new(color.gray, 50), linestyle=hline.style_dotted)
hline(show_er ? 0 : na, "ER 0", color=color.new(color.gray, 70), linestyle=hline.style_solid)

// Optional: ATR (separate pane - different scale from price)
plot(show_atr ? atr_pyramid : na, "ATR(10)", color=color.new(color.maroon, 0), linewidth=2)

// Visual markers for entries and exits - SMALL ARROWS at bar close (on main chart)
plotshape(long_entry and strategy.position_size == 0,
     title="Entry Signal",
     location=location.belowbar,
     color=color.new(color.lime, 0),
     style=shape.arrowup,
     size=size.tiny,
     text="",
     force_overlay=true)

// Special marker for EOD entries (captures gap-ups)
plotshape(long_entry and strategy.position_size == 0 and is_eod_candle,
     title="EOD Entry (Gap-Up Capture)",
     location=location.belowbar,
     color=color.new(color.yellow, 0),
     style=shape.circle,
     size=size.tiny,
     text="EOD",
     force_overlay=true)

plotshape(long_exit and strategy.position_size > 0,
     title="Exit Signal",
     location=location.abovebar,
     color=color.new(color.red, 0),
     style=shape.arrowdown,
     size=size.tiny,
     text="",
     force_overlay=true)

// Info Table showing all conditions in real-time
// DEBUG: Adding visibility confirmation
var table infoTable = na

// DEBUG: Visual confirmation that table code runs (yellow background on last bar)
bgcolor(barstate.islast ? color.new(color.yellow, 90) : na, title="Table Debug Marker")

if barstate.islast
    // Create table fresh on last bar (don't delete, just recreate)
    infoTable := table.new(position.top_right, 3, 23, border_width=2, bgcolor=color.new(color.white, 0), frame_color=color.black, frame_width=2)

    // Calculate position sizing for display using equity high
    risk_amount = equity_high * (risk_percent / 100)
    risk_per_point = close - supertrend
    risk_per_lot = risk_per_point * lot_size
    num_lots_preview = risk_per_lot > 0 ? (risk_amount / risk_per_lot) * er : 0
    final_lots_preview = math.max(1, math.round(num_lots_preview))

    table.cell(infoTable, 0, 0, "Indicator", bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(infoTable, 1, 0, "Value", bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(infoTable, 2, 0, "Status", bgcolor=color.gray, text_color=color.white, text_size=size.normal)

    table.cell(infoTable, 0, 1, "Close")
    table.cell(infoTable, 1, 1, str.tostring(close, "#.##"))
    table.cell(infoTable, 2, 1, "Current Price")

    table.cell(infoTable, 0, 2, "RSI(6)")
    table.cell(infoTable, 1, 2, str.tostring(rsi, "#.##"))
    table.cell(infoTable, 2, 2, rsi_condition ? "✓ >70" : "✗ " + str.tostring(rsi, "#.##"), text_color=rsi_condition ? color.green : color.red)

    table.cell(infoTable, 0, 3, "EMA(200)")
    table.cell(infoTable, 1, 3, str.tostring(ema, "#.##"))
    table.cell(infoTable, 2, 3, ema_condition ? "✓ Above" : "✗ Below", text_color=ema_condition ? color.green : color.red)

    table.cell(infoTable, 0, 4, "DC Upper")
    table.cell(infoTable, 1, 4, str.tostring(dc_upper, "#.##"))
    table.cell(infoTable, 2, 4, dc_condition ? "✓ Above" : "✗ Below", text_color=dc_condition ? color.green : color.red)

    table.cell(infoTable, 0, 5, "ADX(30)")
    table.cell(infoTable, 1, 5, str.tostring(adx, "#.##"))
    table.cell(infoTable, 2, 5, adx_condition ? "✓ <25" : "✗ " + str.tostring(adx, "#.##"), text_color=adx_condition ? color.green : color.red)

    table.cell(infoTable, 0, 6, "ER(3)")
    table.cell(infoTable, 1, 6, str.tostring(er, "#.####"))
    table.cell(infoTable, 2, 6, er_condition ? "✓ >0.8" : "✗ " + str.tostring(er, "#.####"), text_color=er_condition ? color.green : color.red)

    table.cell(infoTable, 0, 7, "SuperTrend")
    table.cell(infoTable, 1, 7, str.tostring(supertrend, "#.##"))
    table.cell(infoTable, 2, 7, st_condition ? "✓ Above" : "✗ Below", text_color=st_condition ? color.green : color.red)

    table.cell(infoTable, 0, 8, "Doji Check")
    table.cell(infoTable, 1, 8, str.tostring(body_size/(candle_range == 0 ? 1 : candle_range), "#.###"))
    table.cell(infoTable, 2, 8, not_doji ? "✓ Not Doji" : "✗ Is Doji", text_color=not_doji ? color.green : color.red)

    table.cell(infoTable, 0, 9, "ENTRY SIGNAL", bgcolor=long_entry ? color.new(color.green, 70) : color.new(color.red, 70))
    table.cell(infoTable, 1, 9, long_entry ? "✓ ALL MET" : "✗ WAITING", text_color=color.white, bgcolor=long_entry ? color.new(color.green, 50) : color.new(color.red, 50))
    table.cell(infoTable, 2, 9, strategy.position_size > 0 ? "IN TRADE" : "NO POSITION", text_color=color.white, bgcolor=strategy.position_size > 0 ? color.new(color.blue, 50) : color.new(color.gray, 50))

    // Position Sizing Info
    table.cell(infoTable, 0, 10, "Capital", bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 1, 10, "₹50L", bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 2, 10, "Initial Capital", bgcolor=color.new(color.blue, 80))

    table.cell(infoTable, 0, 11, "Current Equity", bgcolor=color.new(color.gray, 80))
    table.cell(infoTable, 1, 11, "₹" + str.tostring(current_equity/100000, "#.##") + "L", bgcolor=color.new(color.gray, 80))
    table.cell(infoTable, 2, 11, "Unrealized P&L", bgcolor=color.new(color.gray, 80))

    table.cell(infoTable, 0, 12, "Realized Equity", bgcolor=color.new(color.green, 80))
    table.cell(infoTable, 1, 12, "₹" + str.tostring(realized_equity/100000, "#.##") + "L", bgcolor=color.new(color.green, 80))
    table.cell(infoTable, 2, 12, "Closed Trades", bgcolor=color.new(color.green, 80))

    table.cell(infoTable, 0, 13, "Equity High", bgcolor=color.new(color.teal, 80))
    table.cell(infoTable, 1, 13, "₹" + str.tostring(equity_high/100000, "#.##") + "L", bgcolor=color.new(color.teal, 80))
    table.cell(infoTable, 2, 13, "Peak Realized", bgcolor=color.new(color.teal, 80))

    table.cell(infoTable, 0, 14, "Risk Amount", bgcolor=color.new(color.orange, 80))
    table.cell(infoTable, 1, 14, "₹" + str.tostring(risk_amount/100000, "#.##") + "L", bgcolor=color.new(color.orange, 80))
    table.cell(infoTable, 2, 14, str.tostring(risk_percent, "#.#") + "% of Peak", bgcolor=color.new(color.orange, 80))

    table.cell(infoTable, 0, 15, "Lot Size", bgcolor=color.new(color.purple, 80))
    table.cell(infoTable, 1, 15, str.tostring(final_lots_preview) + " Lots", bgcolor=color.new(color.purple, 80))
    table.cell(infoTable, 2, 15, "If entry now", bgcolor=color.new(color.purple, 80))

    // Pyramiding Info
    table.cell(infoTable, 0, 16, "Pyramids", bgcolor=color.new(color.yellow, 80))
    table.cell(infoTable, 1, 16, str.tostring(pyramid_count) + "/" + str.tostring(max_pyramids), bgcolor=color.new(color.yellow, 80))
    table.cell(infoTable, 2, 16, enable_pyramiding ? (pyramid_count > 0 ? "Active" : "Ready") : "Disabled", bgcolor=color.new(color.yellow, 80))

    table.cell(infoTable, 0, 17, "Open P&L", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
    table.cell(infoTable, 1, 17, "₹" + str.tostring(unrealized_pnl/100000, "#.##") + "L", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
    table.cell(infoTable, 2, 17, str.tostring(unrealized_pnl_r, "#.##") + "R", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))

    // EOD Status (Gap-Up Capture Indicator)
    table.cell(infoTable, 0, 18, "EOD Candle", bgcolor=color.new(is_eod_candle ? color.yellow : color.gray, 80))
    table.cell(infoTable, 1, 18, is_eod_candle ? "YES" : "NO", bgcolor=color.new(is_eod_candle ? color.yellow : color.gray, 80))
    table.cell(infoTable, 2, 18, is_eod_candle ? "Captures Gap-Up" : "Intraday", bgcolor=color.new(is_eod_candle ? color.yellow : color.gray, 80))

    // Margin Information (for Synthetic Futures)
    margin_color = margin_utilization_pct > 90 ? color.red : (margin_utilization_pct > 75 ? color.orange : color.green)
    table.cell(infoTable, 0, 19, "Margin Used", bgcolor=color.new(margin_color, 80))
    table.cell(infoTable, 1, 19, "₹" + str.tostring(current_margin_used_display, "#.#") + "L", bgcolor=color.new(margin_color, 80))
    table.cell(infoTable, 2, 19, str.tostring(margin_utilization_pct, "#.#") + "%", bgcolor=color.new(margin_color, 80))

    table.cell(infoTable, 0, 20, "Margin Free", bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 1, 20, "₹" + str.tostring(margin_remaining, "#.#") + "L", bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 2, 20, "Available", bgcolor=color.new(color.blue, 80))

    // Position Tracking
    table.cell(infoTable, 0, 21, "Total Position", bgcolor=color.new(color.purple, 80))
    table.cell(infoTable, 1, 21, str.tostring(strategy.position_size) + " Lots", bgcolor=color.new(color.purple, 80))
    table.cell(infoTable, 2, 21, "Open Lots", bgcolor=color.new(color.purple, 80))

    // Margin Check Debug
    margin_check_status = use_margin_check ? "ENABLED" : "DISABLED"
    margin_check_color = use_margin_check ? color.green : color.red
    table.cell(infoTable, 0, 22, "Margin Check", bgcolor=color.new(margin_check_color, 80))
    table.cell(infoTable, 1, 22, margin_check_status, bgcolor=color.new(margin_check_color, 80))
    table.cell(infoTable, 2, 22, use_margin_check ? (margin_remaining > 0 ? "Protected" : "Blocked") : "⚠ OFF", bgcolor=color.new(margin_check_color, 80))

// ========================================
// DEBUG PANEL - Shows condition states over time
// ========================================
// Plot all conditions (1 = true, 0 = false) in separate pane
// Display only when show_debug is enabled

plot(show_debug ? (rsi_condition ? 1 : 0) : na, "RSI>70", color=color.new(color.red, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (ema_condition ? 1 : 0) : na, "C>EMA", color=color.new(color.blue, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (dc_condition ? 1 : 0) : na, "C>DC", color=color.new(color.green, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (adx_condition ? 1 : 0) : na, "ADX<25", color=color.new(color.orange, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (er_condition ? 1 : 0) : na, "ER>0.8", color=color.new(color.purple, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (st_condition ? 1 : 0) : na, "C>ST", color=color.new(color.teal, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (not_doji ? 1 : 0) : na, "Not Doji", color=color.new(color.maroon, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (long_entry ? 7 : 0) : na, "ALL CONDITIONS", color=color.new(color.lime, 0), style=plot.style_columns, linewidth=3)
