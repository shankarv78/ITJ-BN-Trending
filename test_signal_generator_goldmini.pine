//@version=5

// ========================================
// TEST SIGNAL GENERATOR v1.0 - GOLD MINI
// For testing Position Calculator webhooks
// ========================================
//
// Purpose: Generate PREDICTABLE trading signals for GOLD_MINI
// - Entry on bar 3
// - Pyramid on bar 6
// - Exit on bar 9
// - Cycle repeats
//
// NO indicator conditions - pure bar counting for reliable testing
//
// Recommended: Apply on MCX Gold Mini 5-min chart
// Output Format: Same JSON as GoldMini_TF_V8.0 for compatibility
// ========================================

strategy("Test Signal Generator GOLD MINI v1.0",
     overlay=true,
     pyramiding=5,
     initial_capital=500000,
     default_qty_type=strategy.fixed,
     default_qty_value=1,
     calc_on_every_tick=false,
     process_orders_on_close=true)

// ========================================
// INPUTS - Signal Configuration
// ========================================
suggested_lots = input.int(1, "Suggested Lots (grams)", minval=1, maxval=100, group="Signal Settings")

// Bar count settings
entry_bar = input.int(3, "Entry on Bar #", minval=1, maxval=50, group="Bar Count Sequence")
pyramid_bar = input.int(6, "Pyramid on Bar #", minval=1, maxval=50, group="Bar Count Sequence")
exit_bar = input.int(9, "Exit on Bar #", minval=1, maxval=50, group="Bar Count Sequence")

// ATR settings for JSON output (Gold Mini typical: 50-150 rupees)
atr_period = input.int(10, "ATR Period", minval=5, maxval=20, group="Indicators")
atr_stop_mult = input.float(1.5, "ATR Stop Multiplier", minval=0.5, maxval=3.0, step=0.1, group="Indicators")

// Manual Trigger (for on-demand testing)
force_entry = input.bool(false, "ðŸŸ¢ Force Entry Signal", group="Manual Triggers", tooltip="Toggle ON then OFF to force an entry")
force_pyramid = input.bool(false, "ðŸŸ¡ Force Pyramid Signal", group="Manual Triggers", tooltip="Toggle ON then OFF to force a pyramid")
force_exit = input.bool(false, "ðŸ”´ Force Exit Signal", group="Manual Triggers", tooltip="Toggle ON then OFF to force an exit")

// Debug
show_debug = input.bool(true, "Show Debug Table", group="Display")

// ========================================
// INSTRUMENT - GOLD_MINI (hardcoded)
// ========================================
instrument_str = "GOLD_MINI"

// ========================================
// INDICATOR CALCULATIONS (for JSON output only)
// ========================================

// ATR for stop calculation and JSON
atr_value = ta.atr(atr_period)

// Efficiency Ratio (ER) - for JSON compatibility
change_sum = math.abs(close - close[10])
volatility_sum = math.sum(math.abs(close - close[1]), 10)
er = volatility_sum != 0 ? change_sum / volatility_sum : 0

// Simple SuperTrend calculation - for JSON compatibility
st_mult = 1.5
st_atr = ta.atr(10)
st_upper = hl2 + st_mult * st_atr
st_lower = hl2 - st_mult * st_atr

var float supertrend = na
var int st_direction = 1

supertrend := st_direction == 1 ? math.max(st_lower, nz(supertrend[1])) : math.min(st_upper, nz(supertrend[1]))
st_direction := close > supertrend ? 1 : close < supertrend ? -1 : st_direction

// ROC - for JSON compatibility
roc = ta.roc(close, 10)

// EMA for visual reference
ema = ta.ema(close, 20)

// ========================================
// BAR COUNT TRACKING
// ========================================
var int bar_counter = 0       // Counts bars in current cycle (1 to exit_bar, then resets)
var int position_count = 0    // 0 = flat, 1 = Long_1, 2 = Long_2, etc.
var float last_entry_price = na

// Increment bar counter every bar
bar_counter := bar_counter + 1

// ========================================
// SIGNAL CONDITIONS - PURE BAR COUNT
// ========================================

// Entry: On entry_bar and we're flat
entry_condition = (bar_counter == entry_bar) and position_count == 0

// Pyramid: On pyramid_bar and we have a position
pyramid_condition = (bar_counter == pyramid_bar) and position_count == 1

// Exit: On exit_bar and we have a position
exit_condition = (bar_counter == exit_bar) and position_count > 0

// Manual overrides
manual_entry = force_entry and force_entry[1] == false and position_count == 0
manual_pyramid = force_pyramid and force_pyramid[1] == false and position_count > 0
manual_exit = force_exit and force_exit[1] == false and position_count > 0

// Combined triggers
trigger_entry = entry_condition or manual_entry
trigger_pyramid = pyramid_condition or manual_pyramid
trigger_exit = exit_condition or manual_exit

// ========================================
// HELPER FUNCTIONS
// ========================================

// Format timestamp - use timenow for current alert time (not candle time)
// IMPORTANT: timenow returns UTC time, so we add 'Z' suffix to indicate UTC timezone
getTimestamp() =>
    str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss}Z", timenow)

// Calculate stop price (Gold Mini: round to 0.5 tick size)
getStopPrice() =>
    raw_stop = close - (atr_value * atr_stop_mult)
    math.round(raw_stop * 2) / 2  // Round to nearest 0.5

// ========================================
// SIGNAL EXECUTION & ALERTS
// ========================================

// Timestamp for JSON
timestamp_str = getTimestamp()
stop_price = getStopPrice()

// BASE ENTRY
if trigger_entry
    position_count := 1
    last_entry_price := close

    strategy.entry("Long_1", strategy.long)

    // Generate JSON alert for GOLD_MINI
    json_entry = '{"type":"BASE_ENTRY", "instrument":"GOLD_MINI", "position":"Long_1", "price":' + str.tostring(close) + ', "stop":' + str.tostring(stop_price) + ', "lots":' + str.tostring(suggested_lots) + ', "atr":' + str.tostring(math.round(atr_value, 1)) + ', "er":' + str.tostring(math.round(er, 2)) + ', "supertrend":' + str.tostring(math.round(supertrend, 1)) + ', "roc":' + str.tostring(math.round(roc, 2)) + ', "timestamp":"' + timestamp_str + '"}'
    alert(json_entry, alert.freq_once_per_bar_close)

// PYRAMID
if trigger_pyramid
    position_count := position_count + 1
    last_entry_price := close

    position_label = "Long_" + str.tostring(position_count)
    strategy.entry(position_label, strategy.long)

    // Generate JSON alert - pyramid lots are half of base (minimum 1)
    pyramid_lots = math.max(1, math.round(suggested_lots / 2))
    json_pyramid = '{"type":"PYRAMID", "instrument":"GOLD_MINI", "position":"' + position_label + '", "price":' + str.tostring(close) + ', "stop":' + str.tostring(stop_price) + ', "lots":' + str.tostring(pyramid_lots) + ', "atr":' + str.tostring(math.round(atr_value, 1)) + ', "er":' + str.tostring(math.round(er, 2)) + ', "supertrend":' + str.tostring(math.round(supertrend, 1)) + ', "roc":' + str.tostring(math.round(roc, 2)) + ', "timestamp":"' + timestamp_str + '"}'
    alert(json_pyramid, alert.freq_once_per_bar_close)

// EXIT
if trigger_exit
    pyramid_lots = math.max(1, math.round(suggested_lots / 2))
    exit_lots = suggested_lots + pyramid_lots  // Entry lots + pyramid lots

    strategy.close_all(comment="EXIT")

    // Generate JSON alert
    json_exit = '{"type":"EXIT", "instrument":"GOLD_MINI", "position":"ALL", "price":' + str.tostring(close) + ', "stop":' + str.tostring(math.round(supertrend, 1)) + ', "entry_price":' + str.tostring(last_entry_price) + ', "lots":' + str.tostring(exit_lots) + ', "reason":"BAR_COUNT", "atr":' + str.tostring(math.round(atr_value, 1)) + ', "er":' + str.tostring(math.round(er, 2)) + ', "supertrend":' + str.tostring(math.round(supertrend, 1)) + ', "roc":' + str.tostring(math.round(roc, 2)) + ', "timestamp":"' + timestamp_str + '"}'
    alert(json_exit, alert.freq_once_per_bar_close)

    // Reset state for next cycle
    position_count := 0
    last_entry_price := na
    bar_counter := 0  // Reset to start new cycle

// ========================================
// VISUAL PLOTS
// ========================================

// EMA for reference
plot(ema, "EMA", color=color.blue, linewidth=1)

// SuperTrend for reference
plot(supertrend, "SuperTrend", color=st_direction == 1 ? color.green : color.red, linewidth=2)

// Entry/Exit markers
plotshape(trigger_entry, "Entry", shape.triangleup, location.belowbar, color.green, size=size.normal)
plotshape(trigger_pyramid, "Pyramid", shape.triangleup, location.belowbar, color.yellow, size=size.small)
plotshape(trigger_exit, "Exit", shape.triangledown, location.abovebar, color.red, size=size.normal)

// Bar number labels (show bar count in cycle)
if show_debug
    label.new(bar_index, high, str.tostring(bar_counter), style=label.style_label_down, color=color.new(color.gray, 80), textcolor=color.white, size=size.tiny)

// ========================================
// DEBUG TABLE
// ========================================

if show_debug and barstate.islast
    var table debug_table = table.new(position.top_right, 2, 12, bgcolor=color.new(color.black, 80), frame_color=color.gold, frame_width=2)

    table.cell(debug_table, 0, 0, "ðŸ¥‡ GOLD MINI TEST", bgcolor=color.new(color.orange, 70), text_color=color.white, text_size=size.normal)
    table.cell(debug_table, 1, 0, "v1.0 BAR COUNT", bgcolor=color.new(color.orange, 70), text_color=color.white, text_size=size.normal)

    table.cell(debug_table, 0, 1, "Instrument", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 1, instrument_str, text_color=color.gold, text_size=size.small)

    table.cell(debug_table, 0, 2, "Current Bar #", text_color=color.gray, text_size=size.small)
    bar_color = bar_counter == entry_bar ? color.green : bar_counter == pyramid_bar ? color.yellow : bar_counter == exit_bar ? color.red : color.white
    table.cell(debug_table, 1, 2, str.tostring(bar_counter), text_color=bar_color, text_size=size.normal)

    table.cell(debug_table, 0, 3, "Sequence", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 3, "Entry@" + str.tostring(entry_bar) + " Pyr@" + str.tostring(pyramid_bar) + " Exit@" + str.tostring(exit_bar), text_color=color.white, text_size=size.tiny)

    table.cell(debug_table, 0, 4, "Position Count", text_color=color.gray, text_size=size.small)
    pos_color = position_count == 0 ? color.gray : color.green
    table.cell(debug_table, 1, 4, str.tostring(position_count), text_color=pos_color, text_size=size.small)

    table.cell(debug_table, 0, 5, "Next Signal", text_color=color.gray, text_size=size.small)
    next_signal = position_count == 0 ? "ENTRY @ bar " + str.tostring(entry_bar) : position_count == 1 ? "PYRAMID @ bar " + str.tostring(pyramid_bar) : "EXIT @ bar " + str.tostring(exit_bar)
    next_color = position_count == 0 ? color.green : position_count == 1 ? color.yellow : color.red
    table.cell(debug_table, 1, 5, next_signal, text_color=next_color, text_size=size.small)

    table.cell(debug_table, 0, 6, "Bars Until Next", text_color=color.gray, text_size=size.small)
    bars_remaining = position_count == 0 ? entry_bar - bar_counter : position_count == 1 ? pyramid_bar - bar_counter : exit_bar - bar_counter
    table.cell(debug_table, 1, 6, str.tostring(bars_remaining), text_color=color.white, text_size=size.normal)

    table.cell(debug_table, 0, 7, "ATR", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 7, str.tostring(math.round(atr_value, 1)), text_color=color.white, text_size=size.small)

    table.cell(debug_table, 0, 8, "ER", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 8, str.tostring(math.round(er, 2)), text_color=color.white, text_size=size.small)

    table.cell(debug_table, 0, 9, "Stop Price", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 9, str.tostring(stop_price), text_color=color.orange, text_size=size.small)

    table.cell(debug_table, 0, 10, "Lots (grams)", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 10, str.tostring(suggested_lots), text_color=color.white, text_size=size.small)

    // Status row
    status_text = position_count == 0 ? "FLAT - Waiting for Bar " + str.tostring(entry_bar) : "IN POSITION - Level " + str.tostring(position_count)
    status_color = position_count == 0 ? color.gray : color.green
    table.cell(debug_table, 0, 11, "Status", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 11, status_text, text_color=status_color, text_size=size.small)

// ========================================
// SAMPLE JSON OUTPUTS (for reference)
// ========================================
//
// BASE_ENTRY (Bar 3):
// {"type":"BASE_ENTRY", "instrument":"GOLD_MINI", "position":"Long_1", "price":7850.5, "stop":7780.0, "lots":1, "atr":47.5, "er":0.82, "supertrend":7780.0, "roc":0.5, "timestamp":"2025-12-08T15:03:00Z"}
//
// PYRAMID (Bar 6):
// {"type":"PYRAMID", "instrument":"GOLD_MINI", "position":"Long_2", "price":7920.0, "stop":7850.0, "lots":1, "atr":48.0, "er":0.85, "supertrend":7850.0, "roc":0.6, "timestamp":"2025-12-08T15:06:00Z"}
//
// EXIT (Bar 9):
// {"type":"EXIT", "instrument":"GOLD_MINI", "position":"ALL", "price":7880.0, "stop":7850.0, "entry_price":7920.0, "lots":2, "reason":"BAR_COUNT", "atr":47.0, "er":0.75, "supertrend":7850.0, "roc":-0.3, "timestamp":"2025-12-08T15:09:00Z"}
//
// ========================================
// NOTES:
// - Gold Mini tick size: â‚¹0.50
// - Lot size: 1 gram
// - Exchange: MCX
// - Symbol format: GOLDM{DDMMMYY}FUT (e.g., GOLDM05JAN26FUT)
// ========================================
// SEQUENCE:
// Bar 1 â†’ Bar 2 â†’ Bar 3 (ENTRY) â†’ Bar 4 â†’ Bar 5 â†’ Bar 6 (PYRAMID) â†’ Bar 7 â†’ Bar 8 â†’ Bar 9 (EXIT) â†’ Reset â†’ Bar 1...
// ========================================
