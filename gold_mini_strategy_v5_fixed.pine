//@version=5
strategy("Gold Mini Trend Following Strategy v5.0",
     overlay=true,
     pyramiding=5,
     initial_capital=5000000,
     default_qty_type=strategy.fixed,
     default_qty_value=1,
     calc_on_every_tick=false,
     calc_on_order_fills=false,
     process_orders_on_close=true,
     commission_type=strategy.commission.percent,
     commission_value=0.05,
     slippage=5)

// ========================================
// MCX GOLD MINI (100g) CONFIGURATION
// ========================================
// Contract: Gold Mini 100g (GOLDMINI on MCX)
// Lot Size: 100g per contract
// Margin: Rs 35,000 per lot
// Trading Hours: 9:00 AM - 11:30 PM (14.5 hours)
// Recommended Timeframe: 60-min (1-hour candles)
// Commission: 0.05% (futures, lower than options)

// ========================================
// PARAMETERS
// ========================================

// RSI Parameters
rsi_period = input.int(6, "RSI Period", minval=1)
rsi_threshold = input.float(70, "RSI Overbought", minval=0, maxval=100, tooltip="Standard overbought level")
rsi_high_threshold = input.float(80, "RSI High Overbought", minval=0, maxval=100, tooltip="High overbought level (more extreme)")

// EMA Parameters
ema_period = input.int(200, "EMA Period", minval=1)

// Donchian Channel Parameters
dc_period = input.int(20, "DC Period", minval=1)

// ADX Parameters
adx_period = input.int(30, "ADX Period", minval=1)
adx_threshold = input.float(20, "ADX Threshold", minval=0, tooltip="✨ GOLD-OPTIMIZED: 20 (more entry opportunities for Gold, empirically validated)")

// Efficiency Ratio Parameters
er_period = input.int(5, "ER Period", minval=1, tooltip="✨ v5: 5 (smoother ER calculation, from Bank Nifty v5)")
er_directional = input.bool(false, "ER Directional")
er_threshold = input.float(0.77, "ER Threshold", minval=0, maxval=1, tooltip="✨ v5: 0.77 (slightly relaxed from 0.8, from Bank Nifty v5)")

// ROC (Rate of Change) Parameters
roc_period = input.int(15, "ROC Period", minval=1, tooltip="Rate of Change lookback period")
use_roc_for_pyramids = input.bool(true, "Use ROC Filter for Pyramids", tooltip="Enable ROC momentum check before pyramiding (recommended for quality control)")
roc_threshold = input.float(5.0, "ROC Threshold %", minval=-10, maxval=20, step=0.5, tooltip="✨ GOLD-OPTIMIZED: 5% (stricter for Gold's smoother trends, empirically validated)")

// SuperTrend Parameters
st_period = input.int(10, "ST Period", minval=1)
st_multiplier = input.float(1.5, "ST Multiplier", minval=0.1, step=0.1)

// Doji Detection Parameter
doji_threshold = input.float(0.1, "Doji Body/Range Ratio", minval=0.01, maxval=0.3, step=0.01, tooltip="Body size as % of candle range. Lower = stricter doji detection")

// Debug Mode
show_debug = input.bool(false, "Show Debug Panel", tooltip="Show detailed condition status in separate pane (not recommended - use info table instead)")

// Indicator Display Options
show_donchian = input.bool(false, "Show Donchian Channel", tooltip="Display DC upper/lower/middle bands on chart")
show_rsi = input.bool(false, "Show RSI", tooltip="Display RSI in separate pane")
show_adx = input.bool(false, "Show ADX", tooltip="Display ADX in separate pane")
show_er = input.bool(false, "Show Efficiency Ratio", tooltip="Display ER in separate pane")
show_atr = input.bool(false, "Show ATR", tooltip="Display ATR in separate pane")

// Info Panel Display Mode - FIXED: Added master toggle
show_info_panel = input.bool(true, "Show Info Panel", tooltip="Master toggle to show/hide the info panel", group="Info Panel")
smart_panel = input.bool(true, "Smart Info Panel", tooltip="Show indicators when flat, trade info when in position", group="Info Panel")
show_all_info = input.bool(false, "Show All Info (Debug)", tooltip="Show both indicators and trade info always (for debugging)", group="Info Panel")

// Position Sizing Parameters
risk_percent = input.float(1.5, "Risk % of Capital", minval=0.1, maxval=10, step=0.1, tooltip="✨ GOLD-OPTIMIZED: 1.5% (more conservative for Gold, empirically validated)")
lot_size = input.int(10, "Point Value (Rs per tick)", minval=1, tooltip="Gold Mini: Rs 10 per tick (100g contract = 10×10g, Re 1 tick × 10 = Rs 10)")

// Margin Management (Gold Mini Futures)
use_margin_check = input.bool(true, "Enable Margin Check", tooltip="Prevent pyramiding if insufficient margin available")
margin_per_lot = input.float(0.75, "Margin per Lot (Lakhs)", minval=0.1, step=0.1, tooltip="✨ GOLD-OPTIMIZED: Rs 75,000 (MCX spec is Rs 72K, but 0.75L adds safety cushion)")
use_leverage = input.bool(false, "Use Leverage", tooltip="Enable leverage for margin calculations")
leverage_multiplier = input.float(1.0, "Leverage Multiplier", minval=0.1, maxval=10, step=0.1, tooltip="Multiply available margin by this factor (1.0 = no leverage, 2.0 = 2x leverage)")

// Pyramiding Parameters
enable_pyramiding = input.bool(true, "Enable Pyramiding", tooltip="Allow adding to winning positions")
max_pyramids = input.int(5, "Max Pyramids", minval=1, maxval=5, tooltip="✨ v5: Up to 6 total positions (extended from 4 in v4)")
atr_pyramid_threshold = input.float(0.5, "ATR Pyramid Threshold", minval=0.25, maxval=2.0, step=0.25, tooltip="✨ GOLD-OPTIMIZED: 0.5 ATR (tighter pyramiding for Gold)")
pyramid_size_ratio = input.float(0.5, "Pyramid Size Ratio", minval=0.25, maxval=1.0, step=0.05, tooltip="Size of each pyramid as ratio of previous entry (0.5 = 50%)")

// Stop Loss Management
stop_loss_mode = input.string("Tom Basso", "Stop Loss Mode", options=["SuperTrend", "Van Tharp", "Tom Basso"], tooltip="Tom Basso (recommended): Independent ATR trailing stops | SuperTrend: All entries use ST as SL | Van Tharp: Trail to breakeven")
atr_period_pyramid = input.int(10, "ATR Period (Pyramiding)", minval=1, tooltip="ATR period for calculating pyramid triggers")

// Tom Basso ATR Trailing Stop Parameters (only used if mode = "Tom Basso")
basso_initial_atr_mult = input.float(1.0, "Basso Initial Stop (× ATR)", minval=0.5, maxval=5.0, step=0.5, tooltip="Initial stop distance from entry (multiplier of ATR)")
basso_trailing_atr_mult = input.float(2.0, "Basso Trailing Stop (× ATR)", minval=1.0, maxval=5.0, step=0.5, tooltip="Trailing stop distance from highest close (multiplier of ATR)")
basso_atr_period = input.int(10, "Basso ATR Period", minval=5, maxval=50, tooltip="ATR period for Tom Basso stop calculation")

// Trade Start Date Filter
use_start_date = input.bool(true, "Use Start Date Filter", tooltip="Only allow trades from specified date onwards")
start_date = input.time(timestamp("11 Nov 2025 00:00 +0000"), "Trade Start Date", tooltip="Strategy will only take trades from this date onwards")

// ========================================
// INDICATOR CALCULATIONS
// ========================================

// RSI
rsi = ta.rsi(close, rsi_period)

// EMA
ema = ta.ema(close, ema_period)

// Donchian Channel (Upper band only for entry condition)
// Use [1] offset to check against PREVIOUS period's high, not including current bar
dc_upper = ta.highest(high[1], dc_period)
dc_lower = ta.lowest(low[1], dc_period)
dc_middle = (dc_upper + dc_lower) / 2

// ADX Calculation
[diPlus, diMinus, adx] = ta.dmi(adx_period, adx_period)

// Efficiency Ratio (Using exact code provided by user)
ER(src, p, dir) =>
    a = dir ? src - src[p] : math.abs(src - src[p])
    b = 0.0
    for i = 0 to p-1
        b := b + math.abs(src[i] - src[i+1])
    result = b != 0 ? a / b : 0
    result

er = ER(close, er_period, er_directional)

// SuperTrend (10, 1.5)
[supertrend, direction] = ta.supertrend(st_multiplier, st_period)

// ATR for Pyramiding
atr_pyramid = ta.atr(atr_period_pyramid)

// ATR for Tom Basso Mode
atr_basso = ta.atr(basso_atr_period)

// ROC (Rate of Change)
roc = ta.roc(close, roc_period)

// Doji Detection
// A doji has a very small body relative to the candle's range
body_size = math.abs(close - open)
candle_range = high - low
is_doji = candle_range > 0 ? (body_size / candle_range) <= doji_threshold : false

// ========================================
// STRATEGY CONDITIONS
// ========================================

// Entry Conditions (ALL must be true at candle close)
rsi_condition = rsi > rsi_threshold
ema_condition = close > ema
dc_condition = close > dc_upper
adx_condition = adx < adx_threshold
er_condition = er > er_threshold
st_condition = close > supertrend  // Price above SuperTrend (bullish)
not_doji = not is_doji  // Candle is NOT a doji

// Date Filter: Only allow trades from start_date onwards
date_filter = use_start_date ? time >= start_date : true

// Combine all conditions for long entry
long_entry = rsi_condition and ema_condition and dc_condition and adx_condition and er_condition and st_condition and not_doji and date_filter

// Exit Condition: Candle closes below SuperTrend
long_exit = close < supertrend

// ========================================
// STRATEGY EXECUTION
// ========================================
// With process_orders_on_close=true:
// - Orders execute at the close of the current bar
// - This captures gap-ups/gap-downs
// - Entry price = close price of signal bar

// ========================================
// PYRAMIDING & POSITION MANAGEMENT
// ========================================
// Van Tharp Principle: Use unrealized profits from current trade for pyramiding decisions
// Risk Management: For new trades use realized equity, for pyramiding use current trade P&L

var float equity_high = strategy.initial_capital  // Track highest equity reached
var float initial_entry_price = na  // First entry price (Long_1)
var float pyr1_entry_price = na  // Pyramid 1 entry price (Long_2)
var float pyr2_entry_price = na  // Pyramid 2 entry price (Long_3)
var float pyr3_entry_price = na  // Pyramid 3 entry price (Long_4)
var float pyr4_entry_price = na  // Pyramid 4 entry price (Long_5) - v5 extension
var float pyr5_entry_price = na  // Pyramid 5 entry price (Long_6) - v5 extension
var float last_pyramid_price = na  // Most recent pyramid entry price
var int pyramid_count = 0  // Number of pyramids added
var float initial_position_size = 0  // Size of first entry

// Tom Basso Mode: Track stops and highest close for each entry
var float basso_stop_long1 = na
var float basso_stop_long2 = na
var float basso_stop_long3 = na
var float basso_stop_long4 = na
var float basso_stop_long5 = na  // v5 extension
var float basso_stop_long6 = na  // v5 extension
var float highest_close_long1 = na
var float highest_close_long2 = na
var float highest_close_long3 = na
var float highest_close_long4 = na
var float highest_close_long5 = na  // v5 extension
var float highest_close_long6 = na  // v5 extension

// EQUITY TRACKING: Track both current and realized equity
current_equity = strategy.equity  // Includes both realized and unrealized P&L (for display and gate)

// V2 PROFIT LOCK-IN: Use equity_high (realized only) for position sizing
// This prevents compounding unrealized gains into new positions
realized_equity = strategy.initial_capital + strategy.netprofit
if realized_equity > equity_high
    equity_high := realized_equity

// Calculate unrealized profit from current open position
unrealized_pnl = strategy.openprofit
// R-multiple: How many times the initial risk we've made in profit
unrealized_pnl_r = strategy.position_size > 0 ? unrealized_pnl / (equity_high * (risk_percent / 100)) : 0

// V2: Accumulated Profit (for pyramid gate check - uses current equity including unrealized)
accumulated_profit = current_equity - strategy.initial_capital

// V2: Margin tracking uses CURRENT EQUITY (includes unrealized profits)
// Allows pyramiding based on current capital, not just realized
realized_equity_lakhs = realized_equity / 100000  // For reference
current_equity_lakhs = current_equity / 100000  // Primary for calculations
available_margin_lakhs = use_leverage ? current_equity_lakhs * leverage_multiplier : current_equity_lakhs
current_margin_used_display = strategy.position_size * margin_per_lot
margin_remaining = available_margin_lakhs - current_margin_used_display
margin_utilization_pct = available_margin_lakhs > 0 ? (current_margin_used_display / available_margin_lakhs) * 100 : 0

// Calculate stop loss levels and risk exposure for display
var float display_stop_long1 = na
var float display_stop_long2 = na
var float display_stop_long3 = na
var float display_stop_long4 = na
var float display_stop_long5 = na  // v5 extension
var float display_stop_long6 = na  // v5 extension

if strategy.position_size > 0
    if stop_loss_mode == "SuperTrend"
        // All positions use SuperTrend
        display_stop_long1 := not na(initial_entry_price) ? supertrend : na
        display_stop_long2 := not na(pyr1_entry_price) ? supertrend : na
        display_stop_long3 := not na(pyr2_entry_price) ? supertrend : na
        display_stop_long4 := not na(pyr3_entry_price) ? supertrend : na
        display_stop_long5 := not na(pyr4_entry_price) ? supertrend : na  // v5
        display_stop_long6 := not na(pyr5_entry_price) ? supertrend : na  // v5
    else if stop_loss_mode == "Van Tharp"
        // Trail to next pyramid or SuperTrend
        display_stop_long1 := not na(initial_entry_price) ? (not na(pyr1_entry_price) ? pyr1_entry_price : supertrend) : na
        display_stop_long2 := not na(pyr1_entry_price) ? (not na(pyr2_entry_price) ? pyr2_entry_price : supertrend) : na
        display_stop_long3 := not na(pyr2_entry_price) ? (not na(pyr3_entry_price) ? pyr3_entry_price : supertrend) : na
        display_stop_long4 := not na(pyr3_entry_price) ? (not na(pyr4_entry_price) ? pyr4_entry_price : supertrend) : na  // v5
        display_stop_long5 := not na(pyr4_entry_price) ? (not na(pyr5_entry_price) ? pyr5_entry_price : supertrend) : na  // v5
        display_stop_long6 := not na(pyr5_entry_price) ? supertrend : na  // v5
    else if stop_loss_mode == "Tom Basso"
        // Individual ATR trailing stops
        display_stop_long1 := basso_stop_long1
        display_stop_long2 := basso_stop_long2
        display_stop_long3 := basso_stop_long3
        display_stop_long4 := basso_stop_long4
        display_stop_long5 := basso_stop_long5  // v5
        display_stop_long6 := basso_stop_long6  // v5

// Calculate risk exposure per position (if stopped out)
risk_long1 = not na(initial_entry_price) and not na(display_stop_long1) ? math.max(0, (initial_entry_price - display_stop_long1) * initial_position_size * lot_size) : 0
risk_long2 = not na(pyr1_entry_price) and not na(display_stop_long2) ? math.max(0, (pyr1_entry_price - display_stop_long2) * initial_position_size * pyramid_size_ratio * lot_size) : 0
risk_long3 = not na(pyr2_entry_price) and not na(display_stop_long3) ? math.max(0, (pyr2_entry_price - display_stop_long3) * initial_position_size * math.pow(pyramid_size_ratio, 2) * lot_size) : 0
risk_long4 = not na(pyr3_entry_price) and not na(display_stop_long4) ? math.max(0, (pyr3_entry_price - display_stop_long4) * initial_position_size * math.pow(pyramid_size_ratio, 3) * lot_size) : 0
risk_long5 = not na(pyr4_entry_price) and not na(display_stop_long5) ? math.max(0, (pyr4_entry_price - display_stop_long5) * initial_position_size * math.pow(pyramid_size_ratio, 4) * lot_size) : 0  // v5
risk_long6 = not na(pyr5_entry_price) and not na(display_stop_long6) ? math.max(0, (pyr5_entry_price - display_stop_long6) * initial_position_size * math.pow(pyramid_size_ratio, 5) * lot_size) : 0  // v5
total_risk_exposure = risk_long1 + risk_long2 + risk_long3 + risk_long4 + risk_long5 + risk_long6  // v5

// V2: Dynamic Base Risk (recalculates as stop trails)
// Base risk is ONLY for Long_1 (initial entry), used for pyramid gate check
base_risk = risk_long1

// INITIAL ENTRY: When all conditions are met and no position exists
if long_entry and strategy.position_size == 0
    // V2 PROFIT LOCK-IN: Calculate risk amount using realized equity only
    // Prevents compounding unrealized gains into new positions
    risk_amount = equity_high * (risk_percent / 100)

    // Entry price and stop
    entry_price = close
    stop_loss = supertrend

    // Risk per lot in points and rupees
    risk_per_point = entry_price - stop_loss
    risk_per_lot = risk_per_point * lot_size

    // Calculate number of lots based on RISK: (Risk ÷ ((Entry - ST) × Lot_Size)) × ER
    risk_based_lots = risk_per_lot > 0 ? (risk_amount / risk_per_lot) * er : 0
    risk_based_lots_floored = math.floor(risk_based_lots)  // Always round DOWN

    // Calculate max lots based on AVAILABLE MARGIN
    margin_based_lots = available_margin_lakhs > 0 ? math.floor(available_margin_lakhs / margin_per_lot) : 0

    // Take MINIMUM of risk-based and margin-based (ensures we never exceed available margin)
    // Both are floored, so final_lots will NEVER exceed available margin
    // Ensure result is valid (0 if less than 1 lot affordable)
    final_lots = math.max(0, math.min(risk_based_lots_floored, margin_based_lots))

    // Only enter if we can afford at least 1 lot
    if final_lots >= 1
        // Store initial entry details
        initial_entry_price := close
        last_pyramid_price := close
        pyramid_count := 0
        initial_position_size := final_lots

        // Initialize Tom Basso stop for Long_1
        if stop_loss_mode == "Tom Basso"
            basso_stop_long1 := close - (basso_initial_atr_mult * atr_basso)
            highest_close_long1 := close

        // Enter with calculated lot size
        entry_comment = "ENTRY-" + str.tostring(final_lots) + "L"
        strategy.entry("Long_1", strategy.long, qty=final_lots, comment=entry_comment)

// V2: Initialize lot constraint variables at appropriate scope for info panel access
float lot_a = 0.0
float lot_b = 0.0
float lot_c = 0.0
float pyramid_lots = 0.0

// PYRAMIDING: V2 Triple-Constraint System
// Only pyramid when meaningful profit exists beyond base risk coverage
if enable_pyramiding and strategy.position_size > 0 and pyramid_count < max_pyramids
    // Calculate how far price has moved from last entry
    price_move_from_last = close - last_pyramid_price
    atr_moves = price_move_from_last / atr_pyramid

    // ========================================
    // V2 PYRAMID GATE CHECK
    // ========================================
    // Gate: Accumulated profit must exceed base trade risk
    // This ensures we only pyramid when we have "house money" beyond covering base risk
    pyramid_gate_open = accumulated_profit > base_risk

    // Calculate profit after base risk coverage (for lot-c calculation)
    profit_after_base_risk = accumulated_profit - base_risk

    // ROC momentum check (optional filter for pyramids)
    roc_ok_for_pyramid = use_roc_for_pyramids ? roc > roc_threshold : true

    // ========================================
    // V2 TRIPLE CONSTRAINT CALCULATION
    // ========================================
    if pyramid_gate_open and atr_moves >= atr_pyramid_threshold and roc_ok_for_pyramid
        // CONSTRAINT 1: lot-a (Margin Safety)
        // Maximum lots affordable based on available margin
        current_margin_used = strategy.position_size * margin_per_lot
        free_margin = available_margin_lakhs - current_margin_used
        lot_a := free_margin > 0 ? math.floor(free_margin / margin_per_lot) : 0

        // CONSTRAINT 2: lot-b (Discipline Safety)
        // Maintain 50% geometric scaling from base position
        lot_b := math.floor(initial_position_size * 0.5)

        // CONSTRAINT 3: lot-c (Profit Safety)
        // Only risk 50% of excess profit (profit beyond base risk)
        available_risk_budget = profit_after_base_risk * 0.5

        // Calculate risk per lot for this pyramid
        pyramid_stop = stop_loss_mode == "SuperTrend" ? supertrend : (stop_loss_mode == "Tom Basso" ? (not na(basso_stop_long1) ? basso_stop_long1 : supertrend) : supertrend)
        pyramid_stop_distance = close - pyramid_stop
        risk_per_lot_pyramid = pyramid_stop_distance * lot_size

        // Calculate lot-c (with zero protection)
        lot_c := risk_per_lot_pyramid > 0 ? math.floor(available_risk_budget / risk_per_lot_pyramid) : 0

        // FINAL PYRAMID SIZE: Minimum of all three constraints
        pyramid_lots := math.min(lot_a, math.min(lot_b, lot_c))
        pyramid_lots := math.max(0, pyramid_lots)  // Ensure non-negative
    // Note: If gate closed or conditions not met, variables remain at initial 0 values

    // Trigger: Gate open AND price moved AND ROC OK AND >= 1 lot
    pyramid_trigger = pyramid_gate_open and atr_moves >= atr_pyramid_threshold and roc_ok_for_pyramid and pyramid_lots >= 1

    if pyramid_trigger

        // Update tracking
        pyramid_count := pyramid_count + 1
        last_pyramid_price := close

        // Track individual pyramid entry prices (for Van Tharp mode)
        if pyramid_count == 1
            pyr1_entry_price := close
            // Initialize Tom Basso stop for Long_2
            if stop_loss_mode == "Tom Basso"
                basso_stop_long2 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long2 := close
        else if pyramid_count == 2
            pyr2_entry_price := close
            // Initialize Tom Basso stop for Long_3
            if stop_loss_mode == "Tom Basso"
                basso_stop_long3 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long3 := close
        else if pyramid_count == 3
            pyr3_entry_price := close
            // Initialize Tom Basso stop for Long_4
            if stop_loss_mode == "Tom Basso"
                basso_stop_long4 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long4 := close
        else if pyramid_count == 4
            pyr4_entry_price := close  // v5 extension
            // Initialize Tom Basso stop for Long_5
            if stop_loss_mode == "Tom Basso"
                basso_stop_long5 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long5 := close
        else if pyramid_count == 5
            pyr5_entry_price := close  // v5 extension
            // Initialize Tom Basso stop for Long_6
            if stop_loss_mode == "Tom Basso"
                basso_stop_long6 := close - (basso_initial_atr_mult * atr_basso)
                highest_close_long6 := close

        // Enter pyramid
        strategy.entry("Long_" + str.tostring(pyramid_count + 1), strategy.long, qty=pyramid_lots, comment="PYR" + str.tostring(pyramid_count) + "-" + str.tostring(pyramid_lots) + "L")

// STOP LOSS MANAGEMENT
if strategy.position_size > 0
    if stop_loss_mode == "SuperTrend"
        // ========================================
        // Mode 1: SuperTrend (Simple)
        // ========================================
        // All positions use SuperTrend as stop
        // ONLY check at bar close (not on every tick) to avoid premature exits
        if close < supertrend and barstate.isconfirmed
            strategy.close_all(comment="EXIT - Below ST")
            // Reset tracking
            initial_entry_price := na
            pyr1_entry_price := na
            pyr2_entry_price := na
            pyr3_entry_price := na
            pyr4_entry_price := na  // v5
            pyr5_entry_price := na  // v5
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

    else if stop_loss_mode == "Van Tharp"
        // ========================================
        // Mode 2: Van Tharp (Trail to Breakeven)
        // ========================================
        // Trail earlier pyramid entries to the entry price of later pyramids
        // Check each position independently (not based on pyramid_count)
        // ONLY check at bar close (not on every tick) to avoid premature exits

        // Long_1 (Initial Entry): Trail to PYR1 or SuperTrend
        if not na(initial_entry_price) and barstate.isconfirmed
            if not na(pyr1_entry_price)
                // PYR1 exists above us, trail to it
                if close < pyr1_entry_price
                    strategy.close("Long_1", comment="EXIT - Trail to PYR1")
                    initial_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_1", comment="EXIT - Below ST")
                    initial_entry_price := na

        // Long_2 (PYR1): Trail to PYR2 or SuperTrend
        if not na(pyr1_entry_price) and barstate.isconfirmed
            if not na(pyr2_entry_price)
                // PYR2 exists above us, trail to it
                if close < pyr2_entry_price
                    strategy.close("Long_2", comment="EXIT - Trail to PYR2")
                    pyr1_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_2", comment="EXIT - Below ST")
                    pyr1_entry_price := na

        // Long_3 (PYR2): Trail to PYR3 or SuperTrend
        if not na(pyr2_entry_price) and barstate.isconfirmed
            if not na(pyr3_entry_price)
                // PYR3 exists above us, trail to it
                if close < pyr3_entry_price
                    strategy.close("Long_3", comment="EXIT - Trail to PYR3")
                    pyr2_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_3", comment="EXIT - Below ST")
                    pyr2_entry_price := na

        // Long_4 (PYR3): Trail to PYR4 or SuperTrend (v5 updated)
        if not na(pyr3_entry_price) and barstate.isconfirmed
            if not na(pyr4_entry_price)
                // PYR4 exists above us, trail to it
                if close < pyr4_entry_price
                    strategy.close("Long_4", comment="EXIT - Trail to PYR4")
                    pyr3_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_4", comment="EXIT - Below ST")
                    pyr3_entry_price := na

        // Long_5 (PYR4): Trail to PYR5 or SuperTrend (v5 extension)
        if not na(pyr4_entry_price) and barstate.isconfirmed
            if not na(pyr5_entry_price)
                // PYR5 exists above us, trail to it
                if close < pyr5_entry_price
                    strategy.close("Long_5", comment="EXIT - Trail to PYR5")
                    pyr4_entry_price := na
            else
                // No pyramid above, use SuperTrend
                if close < supertrend
                    strategy.close("Long_5", comment="EXIT - Below ST")
                    pyr4_entry_price := na

        // Long_6 (PYR5): Always trail to SuperTrend (highest level) (v5 extension)
        if not na(pyr5_entry_price) and barstate.isconfirmed
            if close < supertrend
                strategy.close("Long_6", comment="EXIT - Below ST")
                pyr5_entry_price := na

        // If all positions closed, reset everything
        if strategy.position_size == 0
            initial_entry_price := na
            pyr1_entry_price := na
            pyr2_entry_price := na
            pyr3_entry_price := na
            pyr4_entry_price := na  // v5
            pyr5_entry_price := na  // v5
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

    else if stop_loss_mode == "Tom Basso"
        // ========================================
        // Mode 3: Tom Basso ATR Trailing Stop
        // ========================================
        // Each position has its own ATR-based trailing stop
        // Stop = max(Initial Stop, Highest Close - Trailing ATR)
        // Using manual tracking instead of ta.highest() to avoid buffer issues
        // ONLY check at bar close (not on every tick) to avoid premature exits

        // Update trailing stops for each position
        // Long_1 (Initial Entry)
        if not na(initial_entry_price)
            // Update highest close since entry (on every tick to track the highest)
            highest_close_long1 := math.max(highest_close_long1, close)
            // Calculate trailing stop
            trailing_stop_long1 = highest_close_long1 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long1 := math.max(basso_stop_long1, trailing_stop_long1)  // Only move up

            // Exit Long_1 if close below trailing stop (ONLY at bar close)
            if close < basso_stop_long1 and barstate.isconfirmed
                strategy.close("Long_1", comment="EXIT - Basso Stop")
                initial_entry_price := na
                basso_stop_long1 := na
                highest_close_long1 := na

        // Long_2 (PYR1)
        if not na(pyr1_entry_price)
            highest_close_long2 := math.max(highest_close_long2, close)
            trailing_stop_long2 = highest_close_long2 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long2 := math.max(basso_stop_long2, trailing_stop_long2)

            if close < basso_stop_long2 and barstate.isconfirmed
                strategy.close("Long_2", comment="EXIT - Basso Stop")
                pyr1_entry_price := na
                basso_stop_long2 := na
                highest_close_long2 := na

        // Long_3 (PYR2)
        if not na(pyr2_entry_price)
            highest_close_long3 := math.max(highest_close_long3, close)
            trailing_stop_long3 = highest_close_long3 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long3 := math.max(basso_stop_long3, trailing_stop_long3)

            if close < basso_stop_long3 and barstate.isconfirmed
                strategy.close("Long_3", comment="EXIT - Basso Stop")
                pyr2_entry_price := na
                basso_stop_long3 := na
                highest_close_long3 := na

        // Long_4 (PYR3)
        if not na(pyr3_entry_price)
            highest_close_long4 := math.max(highest_close_long4, close)
            trailing_stop_long4 = highest_close_long4 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long4 := math.max(basso_stop_long4, trailing_stop_long4)

            if close < basso_stop_long4 and barstate.isconfirmed
                strategy.close("Long_4", comment="EXIT - Basso Stop")
                pyr3_entry_price := na
                basso_stop_long4 := na
                highest_close_long4 := na

        // Long_5 (PYR4) - v5 extension
        if not na(pyr4_entry_price)
            highest_close_long5 := math.max(highest_close_long5, close)
            trailing_stop_long5 = highest_close_long5 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long5 := math.max(basso_stop_long5, trailing_stop_long5)

            if close < basso_stop_long5 and barstate.isconfirmed
                strategy.close("Long_5", comment="EXIT - Basso Stop")
                pyr4_entry_price := na
                basso_stop_long5 := na
                highest_close_long5 := na

        // Long_6 (PYR5) - v5 extension
        if not na(pyr5_entry_price)
            highest_close_long6 := math.max(highest_close_long6, close)
            trailing_stop_long6 = highest_close_long6 - (basso_trailing_atr_mult * atr_basso)
            basso_stop_long6 := math.max(basso_stop_long6, trailing_stop_long6)

            if close < basso_stop_long6 and barstate.isconfirmed
                strategy.close("Long_6", comment="EXIT - Basso Stop")
                pyr5_entry_price := na
                basso_stop_long6 := na
                highest_close_long6 := na

        // If all positions closed, reset
        if strategy.position_size == 0
            last_pyramid_price := na
            pyramid_count := 0
            initial_position_size := 0

// ========================================
// PLOTTING
// ========================================

// Always plot EMA and SuperTrend on main chart
plot(ema, "EMA 200", color=color.blue, linewidth=2, force_overlay=true)
plot(supertrend, "SuperTrend (10,1.5)", color=direction < 0 ? color.new(color.green, 0) : color.new(color.red, 0), linewidth=2, style=plot.style_line, force_overlay=true)

// Optional: Donchian Channel on main chart
plot(show_donchian ? dc_upper : na, "DC Upper", color=color.new(color.green, 0), linewidth=1, style=plot.style_line, force_overlay=true)
plot(show_donchian ? dc_lower : na, "DC Lower", color=color.new(color.red, 0), linewidth=1, style=plot.style_line, force_overlay=true)
plot(show_donchian ? dc_middle : na, "DC Middle", color=color.new(color.gray, 50), linewidth=1, style=plot.style_circles, force_overlay=true)

// Optional: RSI (separate pane - different scale from price)
plot(show_rsi ? rsi : na, "RSI(6)", color=color.new(color.purple, 0), linewidth=2)
hline(show_rsi ? 70 : na, "RSI 70", color=color.new(color.red, 50), linestyle=hline.style_dashed)
hline(show_rsi ? 30 : na, "RSI 30", color=color.new(color.green, 50), linestyle=hline.style_dashed)
hline(show_rsi ? 50 : na, "RSI 50", color=color.new(color.gray, 70), linestyle=hline.style_dotted)

// Optional: ADX (separate pane - different scale from price)
plot(show_adx ? adx : na, "ADX(30)", color=color.new(color.orange, 0), linewidth=2)
hline(show_adx ? 25 : na, "ADX 25", color=color.new(color.orange, 50), linestyle=hline.style_dashed)
hline(show_adx ? 50 : na, "ADX 50", color=color.new(color.red, 50), linestyle=hline.style_dotted)

// Optional: Efficiency Ratio (separate pane - different scale from price)
plot(show_er ? er : na, "ER(5)", color=color.new(color.blue, 0), linewidth=2)
hline(show_er ? 0.77 : na, "ER 0.77", color=color.new(color.green, 50), linestyle=hline.style_dashed)
hline(show_er ? 0.5 : na, "ER 0.5", color=color.new(color.gray, 50), linestyle=hline.style_dotted)
hline(show_er ? 0 : na, "ER 0", color=color.new(color.gray, 70), linestyle=hline.style_solid)

// Optional: ATR (separate pane - different scale from price)
plot(show_atr ? atr_pyramid : na, "ATR(10)", color=color.new(color.maroon, 0), linewidth=2)

// Visual markers for entries and exits - SMALL ARROWS at bar close (on main chart)
plotshape(long_entry and strategy.position_size == 0,
     title="Entry Signal",
     location=location.belowbar,
     color=color.new(color.lime, 0),
     style=shape.arrowup,
     size=size.tiny,
     text="",
     force_overlay=true)

plotshape(long_exit and strategy.position_size > 0,
     title="Exit Signal",
     location=location.abovebar,
     color=color.new(color.red, 0),
     style=shape.arrowdown,
     size=size.tiny,
     text="",
     force_overlay=true)

// ========================================
// SMART INFO PANEL - Context-Aware Display (v5 Extended) - FIXED
// ========================================
// FIXED: Added master toggle and proper table management

var table infoTable = table.new(position.top_right, 3, 45, border_width=2, bgcolor=color.new(color.white, 0), frame_color=color.black, frame_width=2)

// Smart Info Panel - Context-Aware Display
if barstate.islast and show_info_panel
    // Clear the table first to avoid stale data
    table.clear(infoTable, 0, 0, 2, 44)
    
    // Determine what to show based on position status
    in_position = strategy.position_size > 0
    show_indicators = (smart_panel and not in_position) or show_all_info
    show_trade_info = (smart_panel and in_position) or show_all_info

    // Header
    table.cell(infoTable, 0, 0, in_position ? "Position" : "Indicator", bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(infoTable, 1, 0, "Value", bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(infoTable, 2, 0, "Status", bgcolor=color.gray, text_color=color.white, text_size=size.normal)

    row = 1

    // === INDICATOR SECTION (when flat or debug mode) ===
    if show_indicators
        table.cell(infoTable, 0, row, "Close")
        table.cell(infoTable, 1, row, str.tostring(close, "#.##"))
        table.cell(infoTable, 2, row, "Current Price")
        row := row + 1

        table.cell(infoTable, 0, row, "RSI(6)")
        table.cell(infoTable, 1, row, str.tostring(rsi, "#.##"))
        table.cell(infoTable, 2, row, rsi_condition ? "✓ >70" : "✗ " + str.tostring(rsi, "#.##"), text_color=rsi_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "EMA(200)")
        table.cell(infoTable, 1, row, str.tostring(ema, "#.##"))
        table.cell(infoTable, 2, row, ema_condition ? "✓ Above" : "✗ Below", text_color=ema_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "DC Upper")
        table.cell(infoTable, 1, row, str.tostring(dc_upper, "#.##"))
        table.cell(infoTable, 2, row, dc_condition ? "✓ Above" : "✗ Below", text_color=dc_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "ADX(30)")
        table.cell(infoTable, 1, row, str.tostring(adx, "#.##"))
        table.cell(infoTable, 2, row, adx_condition ? "✓ <20" : "✗ " + str.tostring(adx, "#.##"), text_color=adx_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "ER(5)")
        table.cell(infoTable, 1, row, str.tostring(er, "#.####"))
        table.cell(infoTable, 2, row, er_condition ? "✓ >0.77" : "✗ " + str.tostring(er, "#.####"), text_color=er_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "SuperTrend")
        table.cell(infoTable, 1, row, str.tostring(supertrend, "#.##"))
        table.cell(infoTable, 2, row, st_condition ? "✓ Above" : "✗ Below", text_color=st_condition ? color.green : color.red)
        row := row + 1

        table.cell(infoTable, 0, row, "Doji Check")
        table.cell(infoTable, 1, row, candle_range > 0 ? str.tostring(body_size/candle_range, "#.###") : "N/A")
        table.cell(infoTable, 2, row, not_doji ? "✓ Not Doji" : "✗ Is Doji", text_color=not_doji ? color.green : color.red)
        row := row + 1

    // === ENTRY SIGNAL (always show) ===
    table.cell(infoTable, 0, row, "ENTRY SIGNAL", bgcolor=long_entry ? color.new(color.green, 70) : color.new(color.red, 70))
    table.cell(infoTable, 1, row, long_entry ? "✓ ALL MET" : "✗ WAITING", text_color=color.white, bgcolor=long_entry ? color.new(color.green, 50) : color.new(color.red, 50))
    table.cell(infoTable, 2, row, in_position ? "IN TRADE" : "NO POSITION", text_color=color.white, bgcolor=in_position ? color.new(color.blue, 50) : color.new(color.gray, 50))
    row := row + 1

    // === TRADE INFO SECTION (when in position or debug mode) ===
    if show_trade_info
        // Position entries and stops with ENHANCED trailing SL display
        if not na(initial_entry_price)
            entry_lots = math.round(initial_position_size)
            // Calculate distance from current stop to entry (for Tom Basso)
            stop_distance_1 = not na(display_stop_long1) ? initial_entry_price - display_stop_long1 : na
            trail_info_1 = stop_loss_mode == "Tom Basso" and not na(highest_close_long1) ? " | Hi:" + str.tostring(highest_close_long1, "#") : ""
            
            table.cell(infoTable, 0, row, "Long_1 Entry", bgcolor=color.new(color.blue, 80))
            table.cell(infoTable, 1, row, str.tostring(initial_entry_price, "#.##") + " (" + str.tostring(entry_lots) + "L)", bgcolor=color.new(color.blue, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long1, "#.##") + trail_info_1, bgcolor=color.new(color.blue, 80))
            row := row + 1

        if not na(pyr1_entry_price)
            pyr1_lots = math.round(initial_position_size * pyramid_size_ratio)
            trail_info_2 = stop_loss_mode == "Tom Basso" and not na(highest_close_long2) ? " | Hi:" + str.tostring(highest_close_long2, "#") : ""
            
            table.cell(infoTable, 0, row, "Long_2 (Pyr1)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr1_entry_price, "#.##") + " (" + str.tostring(pyr1_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long2, "#.##") + trail_info_2, bgcolor=color.new(color.green, 80))
            row := row + 1

        if not na(pyr2_entry_price)
            pyr2_lots = math.round(initial_position_size * math.pow(pyramid_size_ratio, 2))
            trail_info_3 = stop_loss_mode == "Tom Basso" and not na(highest_close_long3) ? " | Hi:" + str.tostring(highest_close_long3, "#") : ""
            
            table.cell(infoTable, 0, row, "Long_3 (Pyr2)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr2_entry_price, "#.##") + " (" + str.tostring(pyr2_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long3, "#.##") + trail_info_3, bgcolor=color.new(color.green, 80))
            row := row + 1

        if not na(pyr3_entry_price)
            pyr3_lots = math.round(initial_position_size * math.pow(pyramid_size_ratio, 3))
            trail_info_4 = stop_loss_mode == "Tom Basso" and not na(highest_close_long4) ? " | Hi:" + str.tostring(highest_close_long4, "#") : ""
            
            table.cell(infoTable, 0, row, "Long_4 (Pyr3)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr3_entry_price, "#.##") + " (" + str.tostring(pyr3_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long4, "#.##") + trail_info_4, bgcolor=color.new(color.green, 80))
            row := row + 1

        // v5 extension - Long_5 and Long_6
        if not na(pyr4_entry_price)
            pyr4_lots = math.round(initial_position_size * math.pow(pyramid_size_ratio, 4))
            trail_info_5 = stop_loss_mode == "Tom Basso" and not na(highest_close_long5) ? " | Hi:" + str.tostring(highest_close_long5, "#") : ""
            
            table.cell(infoTable, 0, row, "Long_5 (Pyr4)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr4_entry_price, "#.##") + " (" + str.tostring(pyr4_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long5, "#.##") + trail_info_5, bgcolor=color.new(color.green, 80))
            row := row + 1

        if not na(pyr5_entry_price)
            pyr5_lots = math.round(initial_position_size * math.pow(pyramid_size_ratio, 5))
            trail_info_6 = stop_loss_mode == "Tom Basso" and not na(highest_close_long6) ? " | Hi:" + str.tostring(highest_close_long6, "#") : ""
            
            table.cell(infoTable, 0, row, "Long_6 (Pyr5)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 1, row, str.tostring(pyr5_entry_price, "#.##") + " (" + str.tostring(pyr5_lots) + "L)", bgcolor=color.new(color.green, 80))
            table.cell(infoTable, 2, row, "SL: " + str.tostring(display_stop_long6, "#.##") + trail_info_6, bgcolor=color.new(color.green, 80))
            row := row + 1

        // Tom Basso specific info row (when in Tom Basso mode)
        if stop_loss_mode == "Tom Basso"
            table.cell(infoTable, 0, row, "Basso ATR", bgcolor=color.new(color.maroon, 80))
            table.cell(infoTable, 1, row, str.tostring(atr_basso, "#.##"), bgcolor=color.new(color.maroon, 80))
            table.cell(infoTable, 2, row, "Init:" + str.tostring(basso_initial_atr_mult, "#.#") + "× Trail:" + str.tostring(basso_trailing_atr_mult, "#.#") + "×", bgcolor=color.new(color.maroon, 80))
            row := row + 1

        // Total position
        table.cell(infoTable, 0, row, "Total Position", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 1, row, str.tostring(strategy.position_size) + " Lots", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 2, row, "@ " + str.tostring(close, "#.##"), bgcolor=color.new(color.purple, 80))
        row := row + 1

        // Risk exposure
        risk_color = total_risk_exposure > equity_high * 0.05 ? color.red : color.orange
        table.cell(infoTable, 0, row, "Risk Exposure", bgcolor=color.new(risk_color, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(total_risk_exposure/100000, "#.##") + "L", bgcolor=color.new(risk_color, 80))
        table.cell(infoTable, 2, row, "If stopped out", bgcolor=color.new(risk_color, 80))
        row := row + 1

        // Open P&L
        table.cell(infoTable, 0, row, "Open P&L", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(unrealized_pnl/100000, "#.##") + "L", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
        table.cell(infoTable, 2, row, str.tostring(unrealized_pnl_r, "#.##") + "R", bgcolor=color.new(unrealized_pnl >= 0 ? color.green : color.red, 80))
        row := row + 1

        // Margin info
        margin_color = margin_utilization_pct > 90 ? color.red : (margin_utilization_pct > 75 ? color.orange : color.green)
        table.cell(infoTable, 0, row, "Margin Used", bgcolor=color.new(margin_color, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(current_margin_used_display, "#.#") + "L", bgcolor=color.new(margin_color, 80))
        table.cell(infoTable, 2, row, str.tostring(margin_utilization_pct, "#.#") + "%", bgcolor=color.new(margin_color, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Margin Free", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(margin_remaining, "#.#") + "L", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 2, row, str.tostring(pyramid_count) + "/" + str.tostring(max_pyramids) + " Pyrs", bgcolor=color.new(color.blue, 80))
        row := row + 1

        // V2: PYRAMID GATE SECTION
        gate_color = accumulated_profit > base_risk ? color.green : color.red
        gate_status = accumulated_profit > base_risk ? "✓ OPEN" : "✗ BLOCKED"
        table.cell(infoTable, 0, row, "Pyramid Gate", bgcolor=color.new(gate_color, 80))
        table.cell(infoTable, 1, row, gate_status, bgcolor=color.new(gate_color, 80))
        table.cell(infoTable, 2, row, "Profit > Risk", bgcolor=color.new(gate_color, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Base Risk", bgcolor=color.new(color.orange, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(base_risk/100000, "#.##") + "L", bgcolor=color.new(color.orange, 80))
        table.cell(infoTable, 2, row, "Long_1 Risk", bgcolor=color.new(color.orange, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Accum Profit", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(accumulated_profit/100000, "#.##") + "L", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 2, row, "R+U Profit", bgcolor=color.new(color.blue, 80))
        row := row + 1

        profit_after_risk_display = accumulated_profit - base_risk
        table.cell(infoTable, 0, row, "Profit-Risk", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(profit_after_risk_display/100000, "#.##") + "L", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 2, row, "Available", bgcolor=color.new(color.purple, 80))
        row := row + 1

        // V2: LOT BREAKDOWN SECTION (when gate is evaluated)
        if enable_pyramiding and pyramid_count < max_pyramids
            table.cell(infoTable, 0, row, "Lot-A (Margin)", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 1, row, str.tostring(lot_a) + " lots", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 2, row, "From Margin", bgcolor=color.new(color.gray, 80))
            row := row + 1

            table.cell(infoTable, 0, row, "Lot-B (50%)", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 1, row, str.tostring(lot_b) + " lots", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 2, row, "Base × 50%", bgcolor=color.new(color.gray, 80))
            row := row + 1

            table.cell(infoTable, 0, row, "Lot-C (Risk)", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 1, row, str.tostring(lot_c) + " lots", bgcolor=color.new(color.gray, 80))
            table.cell(infoTable, 2, row, "From Budget", bgcolor=color.new(color.gray, 80))
            row := row + 1

            min_lot = math.min(lot_a, math.min(lot_b, lot_c))
            limiter = min_lot == lot_a ? "Margin" : (min_lot == lot_b ? "50% Rule" : "Risk Budget")
            table.cell(infoTable, 0, row, "Next Pyramid", bgcolor=color.new(color.yellow, 80))
            table.cell(infoTable, 1, row, str.tostring(min_lot) + " lots", bgcolor=color.new(color.yellow, 80))
            table.cell(infoTable, 2, row, limiter, bgcolor=color.new(color.yellow, 80))
            row := row + 1

    // === CAPITAL INFO (when flat or debug mode) ===
    if not in_position or show_all_info
        // V2 PROFIT LOCK-IN: Calculate position sizing for display (uses realized equity)
        risk_amount = equity_high * (risk_percent / 100)
        risk_per_point = close - supertrend
        risk_per_lot = risk_per_point * lot_size
        risk_lots_preview = risk_per_lot > 0 ? (risk_amount / risk_per_lot) * er : 0
        risk_lots_preview_floored = math.floor(risk_lots_preview)
        margin_lots_preview = available_margin_lakhs > 0 ? math.floor(available_margin_lakhs / margin_per_lot) : 0
        final_lots_preview = math.max(0, math.min(risk_lots_preview_floored, margin_lots_preview))

        table.cell(infoTable, 0, row, "Current Equity", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(current_equity_lakhs, "#.#") + "L", bgcolor=color.new(color.blue, 80))
        table.cell(infoTable, 2, row, "With Unrealized", bgcolor=color.new(color.blue, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Realized Equity", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(realized_equity_lakhs, "#.#") + "L", bgcolor=color.new(color.purple, 80))
        table.cell(infoTable, 2, row, "Booked Only", bgcolor=color.new(color.purple, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Lot Size", bgcolor=color.new(color.orange, 80))
        table.cell(infoTable, 1, row, str.tostring(final_lots_preview) + " Lots", bgcolor=color.new(color.orange, 80))
        table.cell(infoTable, 2, row, "If entry now", bgcolor=color.new(color.orange, 80))
        row := row + 1

        table.cell(infoTable, 0, row, "Margin Avail", bgcolor=color.new(color.green, 80))
        table.cell(infoTable, 1, row, "₹" + str.tostring(available_margin_lakhs, "#.#") + "L", bgcolor=color.new(color.green, 80))
        table.cell(infoTable, 2, row, use_leverage ? str.tostring(leverage_multiplier, "#.#") + "x Lev" : "Realized", bgcolor=color.new(color.green, 80))
        row := row + 1

        // Show SL Mode info when flat
        table.cell(infoTable, 0, row, "SL Mode", bgcolor=color.new(color.maroon, 80))
        table.cell(infoTable, 1, row, stop_loss_mode, bgcolor=color.new(color.maroon, 80))
        if stop_loss_mode == "Tom Basso"
            table.cell(infoTable, 2, row, "ATR(" + str.tostring(basso_atr_period) + ") = " + str.tostring(atr_basso, "#.##"), bgcolor=color.new(color.maroon, 80))
        else
            table.cell(infoTable, 2, row, "Active", bgcolor=color.new(color.maroon, 80))
        row := row + 1

// ========================================
// DEBUG PANEL - Shows condition states over time
// ========================================
// Plot all conditions (1 = true, 0 = false) in separate pane
// Display only when show_debug is enabled

plot(show_debug ? (rsi_condition ? 1 : 0) : na, "RSI>70", color=color.new(color.red, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (ema_condition ? 1 : 0) : na, "C>EMA", color=color.new(color.blue, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (dc_condition ? 1 : 0) : na, "C>DC", color=color.new(color.green, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (adx_condition ? 1 : 0) : na, "ADX<20", color=color.new(color.orange, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (er_condition ? 1 : 0) : na, "ER>0.77", color=color.new(color.purple, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (st_condition ? 1 : 0) : na, "C>ST", color=color.new(color.teal, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (not_doji ? 1 : 0) : na, "Not Doji", color=color.new(color.maroon, 0), style=plot.style_stepline, linewidth=1)
plot(show_debug ? (long_entry ? 7 : 0) : na, "ALL CONDITIONS", color=color.new(color.lime, 0), style=plot.style_columns, linewidth=3)
