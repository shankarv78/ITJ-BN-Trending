//@version=5
// ========================================
// TEST SIGNAL GENERATOR v1.0
// For testing Position Calculator webhooks
// ========================================
//
// Purpose: Generate frequent trading signals on short timeframes
// to test the lovable.dev position calculator integration
//
// Recommended: Apply on 1-min or 5-min chart for quick signal generation
//
// Output Format: Same JSON as BankNifty_TF_V8.0 for compatibility
// ========================================

strategy("Test Signal Generator v1.0",
     overlay=true,
     pyramiding=5,
     initial_capital=5000000,
     default_qty_type=strategy.fixed,
     default_qty_value=1,
     calc_on_every_tick=false,
     process_orders_on_close=true)

// ========================================
// INPUTS - Signal Configuration
// ========================================
instrument_choice = input.string("BANK_NIFTY", "Instrument", options=["BANK_NIFTY", "GOLD_MINI"], group="Signal Settings")
signal_frequency = input.int(3, "Signal Frequency (bars between signals)", minval=1, maxval=20, group="Signal Settings")
max_pyramids = input.int(3, "Max Pyramid Levels", minval=1, maxval=5, group="Signal Settings")
suggested_lots = input.int(2, "Suggested Lots (for JSON)", minval=1, maxval=10, group="Signal Settings")
pyramid_size_ratio = input.float(0.5, "Pyramid Size Ratio", minval=0.1, maxval=1.0, step=0.1, group="Signal Settings", tooltip="Each pyramid = previous Ã— ratio (geometric decay)")

// Entry/Exit Settings
rsi_period = input.int(6, "RSI Period", minval=2, maxval=20, group="Indicators")
rsi_entry_level = input.int(50, "RSI Entry Level", minval=30, maxval=70, group="Indicators")
ema_period = input.int(20, "EMA Period (for exit)", minval=5, maxval=50, group="Indicators")
atr_period = input.int(10, "ATR Period", minval=5, maxval=20, group="Indicators")
atr_stop_mult = input.float(1.5, "ATR Stop Multiplier", minval=0.5, maxval=3.0, step=0.1, group="Indicators")

// Manual Trigger (for on-demand testing)
force_entry = input.bool(false, "ðŸŸ¢ Force Entry Signal", group="Manual Triggers", tooltip="Toggle ON then OFF to force an entry")
force_pyramid = input.bool(false, "ðŸŸ¡ Force Pyramid Signal", group="Manual Triggers", tooltip="Toggle ON then OFF to force a pyramid")
force_exit = input.bool(false, "ðŸ”´ Force Exit Signal", group="Manual Triggers", tooltip="Toggle ON then OFF to force an exit")

// Debug
show_debug = input.bool(true, "Show Debug Table", group="Display")

// ========================================
// INDICATOR CALCULATIONS
// ========================================

// RSI
rsi = ta.rsi(close, rsi_period)

// EMA for exit
ema = ta.ema(close, ema_period)

// ATR for stop calculation and JSON
atr_value = ta.atr(atr_period)

// Efficiency Ratio (ER)
change_sum = math.abs(close - close[10])
volatility_sum = math.sum(math.abs(close - close[1]), 10)
er = volatility_sum != 0 ? change_sum / volatility_sum : 0

// Simple SuperTrend calculation
st_mult = 1.5
st_atr = ta.atr(10)
st_upper = hl2 + st_mult * st_atr
st_lower = hl2 - st_mult * st_atr

var float supertrend = na
var int st_direction = 1

supertrend := st_direction == 1 ? math.max(st_lower, nz(supertrend[1])) : math.min(st_upper, nz(supertrend[1]))
st_direction := close > supertrend ? 1 : close < supertrend ? -1 : st_direction

// ROC
roc = ta.roc(close, 10)

// ========================================
// POSITION STATE TRACKING
// ========================================
var int position_count = 0  // 0 = flat, 1 = Long_1, 2 = Long_2, etc.
var int bars_since_last_signal = 0
var float last_entry_price = na

// Track actual lots for each position level (for accurate exit calculation)
var float lots_level_1 = 0.0
var float lots_level_2 = 0.0
var float lots_level_3 = 0.0
var float lots_level_4 = 0.0
var float lots_level_5 = 0.0

// Track bars
bars_since_last_signal := bars_since_last_signal + 1

// ========================================
// SIGNAL CONDITIONS
// ========================================

// Entry: RSI crosses above entry level AND we're flat
entry_condition = ta.crossover(rsi, rsi_entry_level) and position_count == 0 and bars_since_last_signal >= signal_frequency

// Pyramid: RSI still strong AND we have room AND enough bars passed
pyramid_condition = rsi > rsi_entry_level and position_count > 0 and position_count < max_pyramids and bars_since_last_signal >= signal_frequency and close > last_entry_price

// Exit: Price crosses below EMA OR RSI drops significantly
exit_condition = (ta.crossunder(close, ema) or ta.crossunder(rsi, 30)) and position_count > 0

// Manual overrides
manual_entry = force_entry and force_entry[1] == false and position_count == 0
manual_pyramid = force_pyramid and force_pyramid[1] == false and position_count > 0 and position_count < max_pyramids
manual_exit = force_exit and force_exit[1] == false and position_count > 0

// Combined triggers
trigger_entry = entry_condition or manual_entry
trigger_pyramid = pyramid_condition or manual_pyramid
trigger_exit = exit_condition or manual_exit

// ========================================
// HELPER FUNCTIONS
// ========================================

// Format timestamp
getTimestamp() =>
    str.format("{0,date,yyyy-MM-dd HH:mm:ss}", time)

// Get instrument string
getInstrument() =>
    instrument_choice

// Calculate stop price
getStopPrice() =>
    close - (atr_value * atr_stop_mult)

// ========================================
// SIGNAL EXECUTION & ALERTS
// ========================================

// Timestamp for JSON
timestamp_str = getTimestamp()
instrument_str = getInstrument()
stop_price = getStopPrice()

// BASE ENTRY
if trigger_entry
    position_count := 1
    bars_since_last_signal := 0
    last_entry_price := close
    
    // Track base position lots
    lots_level_1 := suggested_lots
    lots_level_2 := 0.0
    lots_level_3 := 0.0
    lots_level_4 := 0.0
    lots_level_5 := 0.0
    
    strategy.entry("Long_1", strategy.long)
    
    // Generate JSON alert
    json_entry = '{"type":"BASE_ENTRY", "instrument":"' + instrument_str + '", "position":"Long_1", "price":' + str.tostring(close) + ', "stop":' + str.tostring(math.round(stop_price)) + ', "lots":' + str.tostring(suggested_lots) + ', "atr":' + str.tostring(math.round(atr_value)) + ', "er":' + str.tostring(math.round(er, 2)) + ', "supertrend":' + str.tostring(math.round(supertrend)) + ', "roc":' + str.tostring(math.round(roc, 2)) + ', "timestamp":"' + timestamp_str + '"}'
    alert(json_entry, alert.freq_once_per_bar_close)

// PYRAMID
if trigger_pyramid
    position_count := position_count + 1
    bars_since_last_signal := 0
    last_entry_price := close
    
    position_label = "Long_" + str.tostring(position_count)
    
    // Calculate pyramid lots using geometric decay: base_lots Ã— ratio^(pyramid_level-1)
    // position_count is already incremented, so for Long_2 (first pyramid), exponent = 1
    pyramid_lots = math.round(suggested_lots * math.pow(pyramid_size_ratio, position_count - 1))
    pyramid_lots := math.max(pyramid_lots, 1)  // Minimum 1 lot
    
    // Track lots at this level
    if position_count == 2
        lots_level_2 := pyramid_lots
    else if position_count == 3
        lots_level_3 := pyramid_lots
    else if position_count == 4
        lots_level_4 := pyramid_lots
    else if position_count == 5
        lots_level_5 := pyramid_lots
    
    strategy.entry(position_label, strategy.long)
    
    // Generate JSON alert with correct pyramid lots
    json_pyramid = '{"type":"PYRAMID", "instrument":"' + instrument_str + '", "position":"' + position_label + '", "price":' + str.tostring(close) + ', "stop":' + str.tostring(math.round(stop_price)) + ', "lots":' + str.tostring(pyramid_lots) + ', "atr":' + str.tostring(math.round(atr_value)) + ', "er":' + str.tostring(math.round(er, 2)) + ', "supertrend":' + str.tostring(math.round(supertrend)) + ', "roc":' + str.tostring(math.round(roc, 2)) + ', "timestamp":"' + timestamp_str + '"}'
    alert(json_pyramid, alert.freq_once_per_bar_close)

// EXIT
if trigger_exit
    exit_position = "Long_" + str.tostring(position_count)
    
    // Calculate total exit lots by summing all position levels (correct for geometric decay)
    // This is the sum of the geometric series: base + baseÃ—r + baseÃ—rÂ² + ...
    exit_lots = lots_level_1 + lots_level_2 + lots_level_3 + lots_level_4 + lots_level_5
    
    strategy.close_all(comment="EXIT")
    
    // Generate JSON alert with correct total exit lots
    json_exit = '{"type":"EXIT", "instrument":"' + instrument_str + '", "position":"ALL", "price":' + str.tostring(close) + ', "stop":' + str.tostring(math.round(supertrend)) + ', "entry_price":' + str.tostring(math.round(last_entry_price)) + ', "lots":' + str.tostring(math.round(exit_lots)) + ', "reason":"EMA_CROSS", "atr":' + str.tostring(math.round(atr_value)) + ', "er":' + str.tostring(math.round(er, 2)) + ', "supertrend":' + str.tostring(math.round(supertrend)) + ', "roc":' + str.tostring(math.round(roc, 2)) + ', "timestamp":"' + timestamp_str + '"}'
    alert(json_exit, alert.freq_once_per_bar_close)
    
    // Reset state
    position_count := 0
    last_entry_price := na
    lots_level_1 := 0.0
    lots_level_2 := 0.0
    lots_level_3 := 0.0
    lots_level_4 := 0.0
    lots_level_5 := 0.0

// ========================================
// VISUAL PLOTS
// ========================================

// EMA
plot(ema, "EMA", color=color.blue, linewidth=2)

// SuperTrend
plot(supertrend, "SuperTrend", color=st_direction == 1 ? color.green : color.red, linewidth=2)

// Entry/Exit markers
plotshape(trigger_entry, "Entry", shape.triangleup, location.belowbar, color.green, size=size.normal)
plotshape(trigger_pyramid, "Pyramid", shape.triangleup, location.belowbar, color.yellow, size=size.small)
plotshape(trigger_exit, "Exit", shape.triangledown, location.abovebar, color.red, size=size.normal)

// ========================================
// DEBUG TABLE
// ========================================

if show_debug and barstate.islast
    var table debug_table = table.new(position.top_right, 2, 10, bgcolor=color.new(color.black, 80), frame_color=color.gray, frame_width=1)
    
    table.cell(debug_table, 0, 0, "TEST SIGNAL GENERATOR", bgcolor=color.new(color.teal, 70), text_color=color.white, text_size=size.normal)
    table.cell(debug_table, 1, 0, "v1.0", bgcolor=color.new(color.teal, 70), text_color=color.white, text_size=size.normal)
    
    table.cell(debug_table, 0, 1, "Instrument", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 1, instrument_str, text_color=color.white, text_size=size.small)
    
    table.cell(debug_table, 0, 2, "Position Count", text_color=color.gray, text_size=size.small)
    pos_color = position_count == 0 ? color.gray : color.green
    table.cell(debug_table, 1, 2, str.tostring(position_count) + " / " + str.tostring(max_pyramids), text_color=pos_color, text_size=size.small)
    
    table.cell(debug_table, 0, 3, "Bars Since Signal", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 3, str.tostring(bars_since_last_signal), text_color=color.white, text_size=size.small)
    
    table.cell(debug_table, 0, 4, "RSI", text_color=color.gray, text_size=size.small)
    rsi_color = rsi > rsi_entry_level ? color.green : color.red
    table.cell(debug_table, 1, 4, str.tostring(math.round(rsi, 1)), text_color=rsi_color, text_size=size.small)
    
    table.cell(debug_table, 0, 5, "ATR", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 5, str.tostring(math.round(atr_value)), text_color=color.white, text_size=size.small)
    
    table.cell(debug_table, 0, 6, "ER", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 6, str.tostring(math.round(er, 2)), text_color=color.white, text_size=size.small)
    
    table.cell(debug_table, 0, 7, "SuperTrend", text_color=color.gray, text_size=size.small)
    st_color = st_direction == 1 ? color.green : color.red
    table.cell(debug_table, 1, 7, str.tostring(math.round(supertrend)), text_color=st_color, text_size=size.small)
    
    table.cell(debug_table, 0, 8, "Stop Price", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 8, str.tostring(math.round(stop_price)), text_color=color.orange, text_size=size.small)
    
    // Status row
    status_text = position_count == 0 ? "FLAT - Waiting for Entry" : "IN POSITION - " + str.tostring(position_count) + " level(s)"
    status_color = position_count == 0 ? color.gray : color.green
    table.cell(debug_table, 0, 9, "Status", text_color=color.gray, text_size=size.small)
    table.cell(debug_table, 1, 9, status_text, text_color=status_color, text_size=size.small)

// ========================================
// SAMPLE JSON OUTPUTS (for reference)
// ========================================
// 
// With suggested_lots=2 and pyramid_size_ratio=0.5:
//
// BASE_ENTRY (Long_1): 2 lots
// {"type":"BASE_ENTRY", "instrument":"BANK_NIFTY", "position":"Long_1", "price":52000, "stop":51650, "lots":2, "atr":350, "er":0.82, "supertrend":51650, "roc":0.5, "timestamp":"2025-12-04 15:29:45"}
//
// PYRAMID (Long_2): 2 Ã— 0.5^1 = 1 lot
// {"type":"PYRAMID", "instrument":"BANK_NIFTY", "position":"Long_2", "price":52200, "stop":51850, "lots":1, "atr":350, "er":0.85, "supertrend":51850, "roc":0.6, "timestamp":"2025-12-04 15:34:45"}
//
// PYRAMID (Long_3): 2 Ã— 0.5^2 = 1 lot (rounded up from 0.5)
// {"type":"PYRAMID", "instrument":"BANK_NIFTY", "position":"Long_3", "price":52400, "stop":52050, "lots":1, "atr":350, "er":0.88, "supertrend":52050, "roc":0.7, "timestamp":"2025-12-04 15:39:45"}
//
// EXIT: Sum of all positions (2 + 1 + 1 = 4 lots, NOT 3 Ã— 2 = 6)
// {"type":"EXIT", "instrument":"BANK_NIFTY", "position":"ALL", "price":51800, "stop":51650, "entry_price":52000, "lots":4, "reason":"EMA_CROSS", "atr":350, "er":0.75, "supertrend":51650, "roc":-0.3, "timestamp":"2025-12-04 15:44:45"}
//
// ========================================

